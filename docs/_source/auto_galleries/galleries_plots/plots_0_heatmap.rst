
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "_source\auto_galleries\galleries_plots\plots_0_heatmap.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download__source_auto_galleries_galleries_plots_plots_0_heatmap.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr__source_auto_galleries_galleries_plots_plots_0_heatmap.py:


========================================
Heatmap Plot
========================================

.. GENERATED FROM PYTHON SOURCE LINES 9-10

Installation

.. GENERATED FROM PYTHON SOURCE LINES 10-14

.. code-block:: Python


    # To install the required package, use the following command:
    # !pip install mocharts








.. GENERATED FROM PYTHON SOURCE LINES 15-16

Simple Heatmap

.. GENERATED FROM PYTHON SOURCE LINES 16-30

.. code-block:: Python


    from IPython.display import HTML
    import mocharts as mc
    import numpy as np

    uniform_data = np.random.rand(10, 12)
    hm = mc.heatmap(data=uniform_data)
    hm.set_visualmap(height=560, width=20)
    hm.set_figsize((3,3))
    hm.set_toolbox(item_size=30, left='7%')
    # hm.show()
    HTML(hm.show(return_html=True, silent=True))







.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">

                <!DOCTYPE html>
                <html lang="en" style="height: 100%">
                <head>
                <meta charset="utf-8">
                </head>
                <body style="height: 100%; margin: 0">

            
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.5.0/echarts.min.js"></script>
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/echarts-gl/2.0.8/echarts-gl.min.js"></script>
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
                <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/echarts-wordcloud@2.1.0/dist/echarts-wordcloud.min.js"></script>
            
                <div id="1742883545.20966770.4056" style="height: 300px; width: 300px; overflow: auto"></div>
            
                <script type="text/javascript">
                var dom = document.getElementById('1742883545.20966770.4056');
                dom.innerHTML = ""
                dom.setAttribute('_echarts_instance_', '')
                var myChart = echarts.init(dom, null, {
                    renderer: 'canvas',
                    useDirtyRect: false
                    });
                var app = {};

                var option;
        option = {"chart_id": "1742883545.20966770.4056", "link_id": null, "figname": "", "title": null, "grid": {"show": true, "width": "auto", "height": "auto", "z": 2, "left": "5%", "top": "10%", "right": "10%", "bottom": "5%", "borderColor": "#ccc", "borderWidth": 1, "containLabel": true, "backgroundColor": "transparent", "changed_name_key": {"id_": "id"}}, "legend": null, "brush": null, "yAxis": [{"show": true, "type": "category", "position": "bottom", "name": "", "nameLocation": "center", "nameTextStyle": {"color": "#747475", "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "nameGap": "auto", "inverse": true, "splitNumber": 5, "logBase": 10, "axisLine": {}, "axisTick": {"show": true, "alignWithLabel": "none", "interval": "auto", "length": 5}, "axisLabel": {"show": true, "margin": 8, "showMinLabel": true, "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "transparent", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "...", "width": 15.0}, "splitLine": {"show": true, "interval": "auto"}, "splitArea": {"show": false, "interval": "auto"}, "axisPointer": {"show": false}, "dimension": "2d", "ignored": false, "changed_name_key": {"min_": "min", "max_": "max", "type_": "type", "name_": "name"}}], "xAxis": [{"show": true, "type": "category", "position": "bottom", "name": "", "nameLocation": "center", "nameTextStyle": {"color": "#747475", "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "nameGap": 20, "splitNumber": 5, "logBase": 10, "axisLine": {}, "axisTick": {"show": true, "alignWithLabel": "none", "interval": "auto", "length": 5}, "axisLabel": {"show": true, "margin": 8, "showMinLabel": true, "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "transparent", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "...", "width": null}, "splitLine": {"show": true, "interval": "auto"}, "splitArea": {"show": false, "interval": "auto"}, "axisPointer": {"show": false}, "dimension": "2d", "ignored": false, "changed_name_key": {"min_": "min", "max_": "max", "type_": "type", "name_": "name"}}], "parallelAxis": null, "series": [{"type": "heatmap", "name": "heatmap", "colorBy": "series", "z": 2, "legendHoverLink": true, "stackStrategy": "samesign", "cursor": "pointer", "clip": true, "label": {"show": false, "fontSize": 12}, "seriesLayoutBy": "column", "data": [[0, 0, 0.27237584323602104], [0, 1, 0.13796798265975174], [0, 2, 0.30793283623667933], [0, 3, 0.9989549488183307], [0, 4, 0.4314442491757442], [0, 5, 0.26013057248496474], [0, 6, 0.6869341247123241], [0, 7, 0.3245408895678229], [0, 8, 0.1258890159466004], [0, 9, 0.8818753300414314], [0, 10, 0.3325556440402112], [0, 11, 0.700805210836502], [1, 0, 0.5185634768778254], [1, 1, 0.3898332998243985], [1, 2, 0.4617398373114501], [1, 3, 0.1824183902876092], [1, 4, 0.8088947193342724], [1, 5, 0.9645409836780747], [1, 6, 0.16600815858115436], [1, 7, 0.19337814335262438], [1, 8, 0.02811281094761231], [1, 9, 0.45066987592920205], [1, 10, 0.6747926627454269], [1, 11, 0.35751614759199213], [2, 0, 0.07471073163075859], [2, 1, 0.8608367628469993], [2, 2, 0.35581671051846875], [2, 3, 0.868695050519757], [2, 4, 0.17680594890972168], [2, 5, 0.09009777615745984], [2, 6, 0.9090551456216258], [2, 7, 0.7252431430480203], [2, 8, 0.35224525017257646], [2, 9, 0.26985928277264426], [2, 10, 0.10163751047016556], [2, 11, 0.5051672936415349], [3, 0, 0.005511109434659822], [3, 1, 0.8730904668206754], [3, 2, 0.294181087635465], [3, 3, 0.8741599715026078], [3, 4, 0.35795199408788736], [3, 5, 0.4045245968333433], [3, 6, 0.6190307865724818], [3, 7, 0.3606034872071845], [3, 8, 0.6013848673673315], [3, 9, 0.1868771453429936], [3, 10, 0.9486686559988898], [3, 11, 0.47426147309562117], [4, 0, 0.7364853303183831], [4, 1, 0.46810587432003525], [4, 2, 0.42378729392305525], [4, 3, 0.709262833041649], [4, 4, 0.5106172178092351], [4, 5, 0.29757122055843044], [4, 6, 0.8468997441531542], [4, 7, 0.6133222431968983], [4, 8, 0.7271622317739226], [4, 9, 0.3274293399613677], [4, 10, 0.05730557931865332], [4, 11, 0.03501106117933639], [5, 0, 0.18809014294462134], [5, 1, 0.14190334876945132], [5, 2, 0.43521377917387705], [5, 3, 0.1071318346759903], [5, 4, 0.5784224722383547], [5, 5, 0.88409922553051], [5, 6, 0.9241900827852525], [5, 7, 0.4492599479626087], [5, 8, 0.920748592607004], [5, 9, 0.8642344821458507], [5, 10, 0.12203185275410178], [5, 11, 0.258949311965436], [6, 0, 0.7279787444243998], [6, 1, 0.23384975747294323], [6, 2, 0.5566685762432702], [6, 3, 0.3191988097949767], [6, 4, 0.3484252636009233], [6, 5, 0.9445842924282806], [6, 6, 0.3909090453934262], [6, 7, 0.7398794851021748], [6, 8, 0.8138195406763531], [6, 9, 0.9857228624500285], [6, 10, 0.6114281174760708], [6, 11, 0.9655319663802195], [7, 0, 0.5325890469095058], [7, 1, 0.20349285367767433], [7, 2, 0.9667397413083247], [7, 3, 0.5264870474572312], [7, 4, 0.9474805307102734], [7, 5, 0.10090629199986834], [7, 6, 0.8746851441116414], [7, 7, 0.24240035580105979], [7, 8, 0.6651446894829596], [7, 9, 0.5564958145767985], [7, 10, 0.7604909439438715], [7, 11, 0.9295256137638989], [8, 0, 0.14116838459546976], [8, 1, 0.9400521589330242], [8, 2, 0.36966408895210867], [8, 3, 0.9609988722516355], [8, 4, 0.910377793312877], [8, 5, 0.6976189009125657], [8, 6, 0.9436371307582052], [8, 7, 0.3192951021028464], [8, 8, 0.05556427068616665], [8, 9, 0.3119283501744635], [8, 10, 0.5701990954907886], [8, 11, 0.934609830994786], [9, 0, 0.5117145989767983], [9, 1, 0.7406340707495557], [9, 2, 0.032886090326281536], [9, 3, 0.7002179608573725], [9, 4, 0.15120392753450485], [9, 5, 0.5515193523252402], [9, 6, 0.050443129711200796], [9, 7, 0.9656108691422916], [9, 8, 0.48319278717716285], [9, 9, 0.06620887738044512], [9, 10, 0.444715304964857], [9, 11, 0.40691846987010827]], "animation": true, "animationThreshold": 2000, "animationDuration": 1000, "animationEasing": "cubicOut", "animationDurationUpdate": 300, "animationEasingUpdate": "cubicOut", "coordinateSystem": "cartesian2d", "pointSize": 20, "blurSize": 10, "maxOpacity": 1, "progressive": 400, "progressiveThreshold": 3000, "colsize": 1, "visualmap_type": "continuous", "map_range": [0.005511109434659822, 0.9989549488183307]}], "visualMap": {"show": true, "type": "continuous", "color": ["#440154", "#481467", "#482576", "#453781", "#404688", "#39558c", "#33638d", "#2d718e", "#287d8e", "#238a8d", "#1f968b", "#20a386", "#29af7f", "#3dbc74", "#56c667", "#75d054", "#95d840", "#bade28", "#dde318", "#fde725"], "left": "auto", "top": "10%", "right": "1%", "bottom": "auto", "min": 0.005511109434659822, "max": 0.9989549488183307, "calculable": false, "realtime": true, "precision": 2, "itemWidth": 20, "itemHeight": 560, "align": "auto", "textGap": 10, "hoverLink": true, "z": 4, "padding": 0, "backgroundColor": "rgba(0,0,0,0)", "borderColor": "#ccc", "textStyle": {"fontSize": 12, "width": 35, "overflow": "none", "ellipsis": ".."}, "indicatorSize": "50%", "orient": "vertical", "changed_name_key": {"id_": "id", "type_": "type", "min_": "min", "max_": "max", "range_": "range"}}, "toolbox": {"show": true, "orient": "horizontal", "itemSize": 30, "itemGap": 8, "showTitle": true, "feature": {"dataZoom": {}, "saveAsImage": {}}, "z": 2, "left": "7%", "top": "auto", "right": "1%", "bottom": "auto", "width": "auto", "height": "auto", "popup": true, "changed_name_key": {"id_": "id"}}, "tooltip": null, "dataZoom": null, "event": null, "graphic": null, "radar": null, "figsize": {"height": 300, "width": 300}, "color": ["#1f77b4", "#ff7f0e", "#2ca02c", "#e377c2", "#9467bd", "#d62728", "#8c564b", "#bcbd22", "#17becf", "#7f7f7f"], "save_img": false, "auto_size": true, "style": {"overflow": "auto"}, "port": "5005"};function setInnerHTML(elm, html) {
      elm.innerHTML = html;
  
      Array.from(elm.querySelectorAll("script"))
        .forEach( oldScriptEl => {
          const newScriptEl = document.createElement("script");
      
          Array.from(oldScriptEl.attributes).forEach( attr => {
            newScriptEl.setAttribute(attr.name, attr.value) 
          });
      
          const scriptText = document.createTextNode(oldScriptEl.innerHTML);
          newScriptEl.appendChild(scriptText);
      
          oldScriptEl.parentNode.replaceChild(newScriptEl, oldScriptEl);
      });
    };

    function getScreenSize(option) {
      let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_result_save', {
            method: 'post',
            headers: {
              'Content-Type': 'application/json;charset=utf-8;',
              'Access-Control-Allow-Origin':'*',
              'Access-Control-Allow-Credentials': 'true',
              'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
            },
            body: JSON.stringify({'js_func_input':{'height': screen.height, 'width': screen.width},
                                  'event_id': 'screen_size'})
          });
          fetch(testRequest).then(response => {});
      return 
    }
    function support_scientific_notation(option) {
      if (Array.isArray(option['yAxis'])) {
        for (var tar_ind = 0; tar_ind < option['yAxis'].length; tar_ind++) {
          if (option['yAxis'][tar_ind]['type'] === 'value') {
            option['yAxis'][tar_ind]['axisLabel']['formatter'] = function(val) {
              const superscripts = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹','¹⁰',
                        '¹¹', '¹²', '¹³', '¹⁴', '¹⁵', '¹⁶', '¹⁷', '¹⁸', '¹⁹','²⁰',
                        '²¹', '²²', '²³', '²⁴', '²⁵', '²⁶', '²⁷', '²⁸', '²⁹'];
              function toSuperscript(val) {
                if (val.toString().length > 5 && !val.toString().includes('.')) {
                  val = Number(val).toExponential().toString();
                  if (val.includes('-')) {
                    val = val.split('-');
                    var val0 = val[0];
                    var val1 = superscripts[val[1]];
                    return val0 + '⁻' + val1
                  }
                  else if (val.includes('+')) {
                    val = val.split('+');
                    var val0 = val[0];
                    var val1 = superscripts[val[1]];
                    return val0 + '⁺' + val1
                  }
                }
                else {
                  return val
                }
              }
              return toSuperscript(val)
            }
          }
        }
      }
      else {
        if (option['yAxis']['type'] === 'value') {
          option['yAxis']['axisLabel']['formatter'] = function(val) {
            const superscripts = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹','¹⁰',
                    '¹¹', '¹²', '¹³', '¹⁴', '¹⁵', '¹⁶', '¹⁷', '¹⁸', '¹⁹','²⁰',
                    '²¹', '²²', '²³', '²⁴', '²⁵', '²⁶', '²⁷', '²⁸', '²⁹'];
            function toSuperscript(val) {
              if (val.toString().length > 5 && !val.toString().includes('.')) {
                val = Number(val).toExponential().toString();
                if (val.includes('-')) {
                  val = val.split('-');
                  var val0 = val[0];
                  var val1 = superscripts[val[1]];
                  return val0 + '⁻' + val1
                }
                else if (val.includes('+')) {
                  val = val.split('+');
                  var val0 = val[0];
                  var val1 = superscripts[val[1]];
                  return val0 + '⁺' + val1
                }
              }
              else {
                return val
              }
            }
            return toSuperscript(val)
          }
        }
      };
      return option;
    };

    function auto_component_size(option) {
      if (typeof option['figsize']['width'] === 'string' || option['figsize']['width'] instanceof String) {
        if (option['figsize']['width'].includes('%')) {
          var width = 800 * (parseFloat(option['figsize']['width'].slice(0,-1)) / 100);
        }
        else if (option['figsize']['width'].includes('px')) {
          var width = parseFloat(option['figsize']['width'].slice(0,-2));
        }
      }
      else {
        var width = option['figsize']['width']
      }

      if (typeof option['figsize']['height'] === 'string' || option['figsize']['height'] instanceof String) {
        if (option['figsize']['height'].includes('%')) {
          var height = 600 * (parseFloat(option['figsize']['height'].slice(0,-1)) / 100);
        }
        else if (option['figsize']['height'].includes('px')) {
          var height = parseFloat(option['figsize']['height'].slice(0,-2));
        }
      }
      else {
        var height = option['figsize']['height']
      }

      var relative_ratio = Math.min(width / 700, height / 400)
      if ('xAxis3D' in option) {
        var keys = ['xAxis3D', 'yAxis3D', 'zAxis3D']
      }
      else {
        var keys = ['xAxis', 'yAxis']
      }
      for (single_key of keys) {
        for (var ind = 0; ind < option[single_key].length; ind++) {
          option[single_key][ind]['nameTextStyle']['fontSize'] = Math.max(7, option[single_key][ind]['nameTextStyle']['fontSize'] * relative_ratio);
          option[single_key][ind]['axisLabel']['fontSize'] = Math.max(7, option[single_key][ind]['axisLabel']['fontSize'] * relative_ratio);
        }
      }
      if (option['series']) {
        for (var ind = 0; ind < option['series'].length; ind++) {
          if (['heatmap', 'bar'].includes(option['series'][ind]['type'])) {
            if (option['series'][ind]['label']) {
              option['series'][ind]['label']['fontSize'] = Math.max(7, option['series'][ind]['label']['fontSize'] * relative_ratio);
            }
          }
        }
      }
      if (option['title']) {
        if (Array.isArray(option['title'])) {
          for (var ind = 0; ind < option['title'].length; ind++) {
            option['title'][ind]['textStyle']['fontSize'] = Math.max(9, option['title'][ind]['textStyle']['fontSize'] * relative_ratio);
          }
        }
        else {
          option['title']['textStyle']['fontSize'] = Math.max(9, option['title']['textStyle']['fontSize'] * relative_ratio);
        }
      }
      if (option['legend']) {
        option['legend']['itemHeight'] = option['legend']['itemHeight'] * relative_ratio;
        option['legend']['itemWidth'] = option['legend']['itemWidth'] * relative_ratio;
        option['legend']['textStyle']['fontSize'] = Math.max(7, option['legend']['textStyle']['fontSize'] * relative_ratio);
      }
      if (option['visualMap']) {
        option['visualMap']['itemHeight'] = option['visualMap']['itemHeight'] * relative_ratio;
        option['visualMap']['itemWidth'] = option['visualMap']['itemWidth'] * relative_ratio;
        option['visualMap']['textStyle']['fontSize'] = Math.max(7, option['visualMap']['textStyle']['fontSize'] * relative_ratio);
      }
      if (option['toolbox']) {
        option['toolbox']['itemSize'] = Math.max(8, option['toolbox']['itemSize'] * relative_ratio)
        option['toolbox']['itemGap'] = Math.max(4, option['toolbox']['itemGap'] * relative_ratio);
      }
      if (option['graphic']) {
        for (var ind = 0; ind < option['graphic'].length; ind++) {
          for (var ind2 = 0; ind2 < option['graphic'][ind]['children'].length; ind2++) {
            var new_font = Math.max(7, 12 * relative_ratio);
            option['graphic'][ind]['children'][ind2]['style']['font'] = new_font.toString() + 'px Microsoft YaHei';
          }
        }
      }
      return option;
    }

    function save_img(echarts_instance, option) {
      const base64_str = echarts_instance.getDataURL({
          pixelRatio: 2,
          backgroundColor: '#fff',
          width: option['figsize']['width'],
          height: option['figsize']['height']
      });

      let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_image_save', {
        method: 'post',
        headers: {
          'Content-Type': 'application/json;charset=utf-8;',
          'Access-Control-Allow-Origin':'*',
          'Access-Control-Allow-Credentials': 'true',
          'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
        },
        body: JSON.stringify({'figname': option['figname'],
                              'base64_str': base64_str})
      });
      fetch(testRequest).then(response => {});
    };


    function auto_axis_namegap(echarts_instance, auto_axis_list, axis_type) {
      const globalModel = echarts_instance._api.getModel()
      const figsize = globalModel.option.figsize
      const ctx = document.createElement('canvas').getContext('2d')
      if (typeof globalModel.option['figsize']['width'] === 'string' || globalModel.option['figsize']['width'] instanceof String) {
        if (globalModel.option['figsize']['width'].includes('%')) {
          var width = 800 * (parseFloat(globalModel.option['figsize']['width'].slice(0,-1)) / 100);
        }
        else if (globalModel.option['figsize']['width'].includes('px')) {
          var width = parseFloat(globalModel.option['figsize']['width'].slice(0,-2));
        }
      }
      else {
        var width = globalModel.option['figsize']['width'];
      }

      if (typeof globalModel.option['figsize']['height'] === 'string' || globalModel.option['figsize']['height'] instanceof String) {
        if (globalModel.option['figsize']['height'].includes('%')) {
          var height = 600 * (parseFloat(globalModel.option['figsize']['height'].slice(0,-1)) / 100);
        }
        else if (globalModel.option['figsize']['height'].includes('px')) {
          var height = parseFloat(globalModel.option['figsize']['height'].slice(0,-2));
        }
      }
      else {
        var height = option['figsize']['height'];
      }
      var relative_ratio = Math.min(width / 700, height / 400);
      if (axis_type==='2d') {
        const yAxisList = globalModel.option.yAxis
        const xAxisList = globalModel.option.xAxis

        for (var axis_idx of auto_axis_list) {
          const yAxis = yAxisList[axis_idx]
          const fontSize = yAxis.nameTextStyle?.fontSize ?? 12
          const fontFamily = yAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
          ctx.save()
          ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
  
          const yAxisComponent = globalModel.getComponent('yAxis', axis_idx)?.axis
          if (yAxis.type === 'value') {
            var labelMaxWidth = Math.min(Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
          }
          else {
            var labelMaxWidth = Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
          }
          var axisLabelMargin = yAxis.axisLabel?.margin ?? 8
          axisLabelMargin = axisLabelMargin * relative_ratio
          yAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
          ctx.restore()
        };
  
        for (var axis_idx of [...Array(xAxisList.length).keys()]) {
          var new_gap = Math.max(xAxisList[axis_idx].nameGap * relative_ratio, 12);
          if (figsize['height'] < 400) {
            new_gap = Math.min(20, new_gap);
          }
          xAxisList[axis_idx].nameGap = new_gap;
        }
  
        echarts_instance.setOption({
          yAxis: yAxisList,
          xAxis: xAxisList
        })
      }
      else {
        const yAxisList = globalModel.option.yAxis3D
        const xAxisList = globalModel.option.xAxis3D
        const zAxisList = globalModel.option.zAxis3D

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < xAxisList.length) {
            const xAxis = xAxisList[axis_idx]
            const fontSize = xAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = xAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const xAxisComponent = globalModel.getComponent('xAxis3D', axis_idx)?.axis
            if (xAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...xAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...xAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = xAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            xAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < yAxisList.length) {
            const yAxis = yAxisList[axis_idx]
            const fontSize = yAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = yAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const yAxisComponent = globalModel.getComponent('yAxis3D', axis_idx)?.axis
            if (yAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = yAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            yAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < zAxisList.length) {
            const zAxis = zAxisList[axis_idx]
            const fontSize = zAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = zAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const zAxisComponent = globalModel.getComponent('zAxis3D', axis_idx)?.axis
            if (zAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...zAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...zAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = zAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            zAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };
        echarts_instance.setOption({
          yAxis3D: yAxisList,
          xAxis3D: xAxisList,
          zAxis3D: zAxisList
        });
        }
  
    };

    function custom_scatter_size(option) {
  
      for (var ind = 0; ind < option['series'].length; ind++) {
        if (option['series'][ind]['symbolSize'] === 'array_size') {
          var ind_ = option['series'][ind]['data_dict']['size']
          option['series'][ind]['symbolSize'] = function (data) {return data[ind_];}
        }
      }
      return option;
  
    };

    function show_scatter_label(option) {
  
      for (var ind = 0; ind < option['series'].length; ind++) {
        if (option['series'][ind]['label'] === 'show_label') {
          var ind_ = option['series'][ind]['data_dict']['label']
          option['series'][ind]['label'] = {
            show: true,
            formatter: function (params) {return params.data.value[ind_]; }
          }
        }
      }
      return option;
    };

    function hide_min_max_axis_label(option) {
      for (var ind = 0; ind < option['xAxis3D'].length; ind++) {
        if (option['xAxis3D'][ind]['type'] == 'value') {
          var x_min = option['xAxis3D'][ind]['min']
          var x_max = option['xAxis3D'][ind]['max']
          option['xAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==x_min || value==x_max){}
            else {return value}
          }
        }
      }
      for (var ind = 0; ind < option['yAxis3D'].length; ind++) {
        if (option['yAxis3D'][ind]['type'] == 'value') {  
          var y_min = option['yAxis3D'][ind]['min']
          var y_max = option['yAxis3D'][ind]['max']
          option['yAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==y_min || value==y_max){}
            else {return value}
          }
        }
      }
      for (var ind = 0; ind < option['zAxis3D'].length; ind++) {
        if (option['zAxis3D'][ind]['type'] == 'value') {
          var z_min = option['zAxis3D'][ind]['min']
          var z_max = option['zAxis3D'][ind]['max']
          option['zAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==z_min || value==z_max){}
            else {return value}
          }
       }
      }
      return option;
    }

    function custom_axis_label(option) {
      if (Array.isArray(option['xAxis'])) {
        for (var ind = 0; ind < option['xAxis'].length; ind++) {
          if (option['xAxis'][ind]['axisLabel']['formatter_func']) {
            var f = new Function(option['xAxis'][ind]['axisLabel']['formatter_func'].arguments,
                                 option['xAxis'][ind]['axisLabel']['formatter_func'].body)
            option['xAxis'][ind]['axisLabel']['formatter'] = f
          }
        }
      }
      else {
        if (option['xAxis']['axisLabel']['formatter_func']) {
          var f = new Function(option['xAxis']['axisLabel']['formatter_func'].arguments,
                               option['xAxis']['axisLabel']['formatter_func'].body)
          option['xAxis']['axisLabel']['formatter'] = f
        }
      }
      if (Array.isArray(option['yAxis'])) {
        for (var ind = 0; ind < option['yAxis'].length; ind++) {
          if (option['yAxis'][ind]['axisLabel']['formatter_func']) {
            var f = new Function(option['yAxis'][ind]['axisLabel']['formatter_func'].arguments,
                                 option['yAxis'][ind]['axisLabel']['formatter_func'].body)
            option['yAxis'][ind]['axisLabel']['formatter'] = f
          }
        }
      }
      else {
        if (option['yAxis']['axisLabel']['formatter_func']) {
          var f = new Function(option['yAxis']['axisLabel']['formatter_func'].arguments,
                               option['yAxis']['axisLabel']['formatter_func'].body)
          option['yAxis']['axisLabel']['formatter'] = f
        }
      }
      return option;
    }

    function custom_tooltip(option, dimension=2) {

      if (dimension === 2) {
        var xaxis_key = 'xAxis'
        var yaxis_key = 'yAxis'
      }

      else if (dimension === 3) {
        var xaxis_key = 'xAxis3D'
        var yaxis_key = 'yAxis3D'
        var zaxis_key = 'zAxis3D'
      }

      if (option['radar']) {
        var radar_names = []
        for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
          radar_names.push(option['radar']['indicator'][ind_]['name']) 
        }
      }
  
  
      if (option[xaxis_key]['name'] !== null && option[xaxis_key]['name'] !== '' && Array.isArray(option[xaxis_key])!==true) {
        var xaxis_name = option[xaxis_key]['name'];
      }
      else {
        var xaxis_name = 'X';
      }

      if (option[yaxis_key]['name'] !== null && option[yaxis_key]['name'] !== ''&& Array.isArray(option[xaxis_key])!==true) {
        var yaxis_name = option[yaxis_key]['name'];
      }
      else {
        var yaxis_name = 'Y';
      }

      if (typeof zaxis_key !== 'undefined') {
        if (option[zaxis_key]['name'] !== ''&& Array.isArray(option[xaxis_key])!==true) {
          var zaxis_name = option[zaxis_key]['name'];
        }
        else {
          var zaxis_name = 'Z';
        }
      }
  
      if (option['tooltip']) {
        if (option['tooltip']['precision']) {
          var precision = option['tooltip']['precision']
          option['tooltip']['valueFormatter'] = (value) =>  Math.round(Number(value) * (10**precision)) / (10**precision)
        }

        for (var ind_ = 0; ind_ < option['series'].length; ind_++) {
          if (option['series'][ind_]['tooltip']) {
            if (option['series'][ind_]['tooltip']['precision']) {
              var precision = option['series'][ind_]['tooltip']['precision']
              const fix = precision_ => value => Math.round(Number(value) * (10**precision_)) / (10**precision_),
              fix_p = fix(precision);
              option['series'][ind_]['tooltip']['valueFormatter'] = function (value) {
                return fix_p(value)
              } 
            }
          }
        }

        if (option['series'].length === 1) {
          if (['scatter', 'heatmap', 'scatter3D', 'radar'].includes(option['series'][0]['type'])) {
            option['tooltip']['formatter'] = function(params) {
              if (params.seriesName.includes('series')) {
                var series_name = ''
              }
          
              else {
                var series_name = params.seriesName + '<br>'
              }
      
              if (params.seriesType === 'scatter') {
                if (option['tooltip']['custom_tooltip'] === true) {
                  formatter = series_name
                    + params.value[dimension]
                }
                else {
                  formatter = series_name
                  + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                  +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                }
            
              }
  
              else if (params.seriesType === 'heatmap') {
                formatter = params.name + ', ' + option['yAxis'][0]['data'][params.data[1]] + '<br> <b>' + Math.round(params.data[2] * 10000) / 10000
              }
      
              else if (params.seriesType === 'scatter3D') {
                if (option['tooltip']['custom_tooltip'] === true) {
                  formatter = series_name
                    + params.value[dimension]
                }
                else {
                  formatter = series_name
                    + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                    +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                    +'<br>' + zaxis_name + ': ' + Math.round(params.value[2] * 100) / 100
                }
              }
          
              else if (params.seriesType === 'radar') {
                formatter = params.name  + '<br>';
                for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
                  if (ind_ !== option['radar']['indicator'].length - 1) {
                    formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100 + '<br>'
                  }
                  else {
                    formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100
                  }
                }
              }
            return formatter;
            }
          }
        }
        else {
          for (var out_ind_ = 0; out_ind_ < option['series'].length; out_ind_++) {
            if (['scatter', 'heatmap', 'scatter3D', 'radar'].includes(option['series'][out_ind_]['type'])) {
              if (option['series'][out_ind_]['tooltip']) {
              }
              else {
                option['series'][out_ind_]['tooltip'] = {}
              }
              option['series'][out_ind_]['tooltip']['formatter'] = function(params) {
                if (params.seriesName.includes('series')) {
                  var series_name = ''
                }
            
                else {
                  var series_name = params.seriesName + '<br>'
                }
        
                if (params.seriesType === 'scatter') {
                  if (option['tooltip']['custom_tooltip'] === true) {
                    formatter = series_name
                      + params.value[dimension]
                  }
                  else {
                    formatter = series_name
                      + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                      +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                  }
                }
    
                else if (params.seriesType === 'heatmap') {
                  if ('data' in option['yAxis'][option['series'][params.seriesIndex]['yAxisIndex']]) {
                    formatter = params.name + ', ' + option['yAxis'][option['series'][params.seriesIndex]['yAxisIndex']]['data'][params.data[1]] + '<br> <b>' + Math.round(params.data[2] * 10000) / 10000
                  }
                  else {
                    formatter = Math.round(params.data[2] * 10000) / 10000
                  }
                
                }
        
                else if (params.seriesType === 'scatter3D') {
                  if (option['tooltip']['custom_tooltip'] === true) {
                    formatter = series_name
                      + params.value[dimension]
                  }
                  else {
                    formatter = series_name
                      + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                      +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                      +'<br>' + zaxis_name + ': ' + Math.round(params.value[2] * 100) / 100
                  }
                }
            
                else if (params.seriesType === 'radar') {
                  formatter = params.name  + '<br>';
                  for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
                    if (ind_ !== option['radar']['indicator'].length - 1) {
                      formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100 + '<br>'
                    }
                    else {
                      formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100
                    }
                  }
                }
              return formatter;
              }
            }
          }
        }
      }
      return option;
    };

    function support_brush_event(option) {
      if (option['event']['type_'] === 'brushselected') {
        if (option['link_id'] === null) {
          var link_id = option['chart_id'];
        }
        else {
          var link_id = option['link_id'];
        }
        var dom = document.getElementById(link_id);
        var bind_chart = echarts.init(dom, null, {
            renderer: 'canvas',
            useDirtyRect: false
        });
        var last_selected = [];
        bind_chart.on(option['event']['type_'], (params) => {
          var brushed = [];
          var brushComponent = params.batch[0];
          for (var sIdx = 0; sIdx < brushComponent.selected.length; sIdx++) {
            var rawIndices = brushComponent.selected[sIdx].dataIndex;
            brushed.push(rawIndices);
          }
          var brushed_all = brushed[0];

          if (JSON.stringify(last_selected) !== JSON.stringify(brushed_all)) {

            // Update memory
            let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_call_python_function', {
              method: 'post',
              headers: {
                  'Content-Type': 'application/json;charset=utf-8;',
                  'Access-Control-Allow-Origin':'*',
                  'Access-Control-Allow-Credentials': 'true',
                  'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
              },
              body: JSON.stringify({'js_func_input':{'selected': brushed_all},
                                    'event_id': option['event']['event_id']})
            });
            var dom_dict = {}
            fetch(testRequest).then(response => {
              var result = response.json();
              result.then(res => {
                dom_dict[res['link_id']] = document.getElementById(res['link_id']);
                setInnerHTML(dom_dict[res['link_id']], res['html']);
              });
            });
            last_selected = brushed_all;
          }
                            
        // bind_chart.setOption(option);
        })
      }
      return option;
    };

    function support_click_event(option) {
      if (option['event']['type_'] === 'click') {
        if (option['link_id'] === null) {
          var link_id = option['chart_id'];
        }
        else {
          var link_id = option['link_id'];
        }
        var dom = document.getElementById(link_id);
        var bind_chart = echarts.init(dom, null, {
            renderer: 'canvas',
            useDirtyRect: false
        });

        if (option['series'][0]['orient'] === 'vertical') {
          var value_idx = 0
        }
        else {
          var value_idx = 1
        }
    

        bind_chart.on(option['event']['type_'], (params) => {
          if (option['event']['task'] === 'singleselect') {
            for (var ind_2 = 0; ind_2 < option['series'][0]['data'].length; ind_2++) {
              if (option['series'][0]['data'][ind_2]['itemStyle']['color'] !== '#1f77b4') {
                option['series'][0]['data'][ind_2]['itemStyle']['color'] = '#1f77b4';
              }
            }
            var idx = option['series'][0]['x_value'].indexOf(params.value[value_idx])
            option['series'][0]['data'][idx]['itemStyle']['color'] = '#ff7f0e';

            var selected = params.value[value_idx];
          }
          else {
            console.log(params);
          }
      
          let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_call_python_function', {
            method: 'post',
            headers: {
              'Content-Type': 'application/json;charset=utf-8;',
              'Access-Control-Allow-Origin':'*',
              'Access-Control-Allow-Credentials': 'true',
              'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
            },
            body: JSON.stringify({'js_func_input':{'selected': selected},
                                  'event_id': option['event']['event_id']})
          });
          var dom_dict = {}
          fetch(testRequest).then(response => {
            var result = response.json();
            result.then(res => {
              dom_dict[res['link_id']] = document.getElementById(res['link_id']);
              setInnerHTML(dom_dict[res['link_id']], res['html']);
            });
          });
          bind_chart.setOption(option);
        });
      }
      return option;
    };function support_popup(option, height, width, inner_html) {
      option['toolbox']['feature']['myFeature'] = {
        show: true,
        title: 'Open in new window',
        icon: "image://data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iNDhweCIgd2lkdGg9IjQ4cHgiIHZpZXdCb3g9IjE2MCAtODAwIDY0MCA2NDAiIGZpbGw9IiM2NjY2NjYiPg0KICA8cGF0aCBkPSJNMjE1LjM4LTE2MHEtMjMuMDUgMC0zOS4yMi0xNi4xNlExNjAtMTkyLjMzIDE2MC0yMTUuMzh2LTUyOS4yNHEwLTIzLjA1IDE2LjE2LTM5LjIyUTE5Mi4zMy04MDAgMjE1LjM4LTgwMGgyMjQuMzl2MzAuNzdIMjE1LjM4cS05LjIzIDAtMTYuOTIgNy42OS03LjY5IDcuNjktNy42OSAxNi45MnY1MjkuMjRxMCA5LjIzIDcuNjkgMTYuOTIgNy42OSA3LjY5IDE2LjkyIDcuNjloNTI5LjI0cTkuMjMgMCAxNi45Mi03LjY5IDcuNjktNy42OSA3LjY5LTE2Ljkydi0yMjQuMzlIODAwdjIyNC4zOXEwIDIzLjA1LTE2LjE2IDM5LjIyUTc2Ny42Ny0xNjAgNzQ0LjYyLTE2MEgyMTUuMzhabTE3MS4yNC0yMDQuMzgtMjItMjIuMjQgMzgyLjYxLTM4Mi42MUg1NDEuMzFWLTgwMEg4MDB2MjU4LjY5aC0zMC43N1YtNzQ3TDM4Ni42Mi0zNjQuMzhaIi8+DQo8L3N2Zz4NCg==",
        onclick: function (){
          var height_ = Math.min(screen.height, Math.round(1.5 * parseInt(height.slice(0,-2))))
          var width_ = Math.min(screen.width, Math.round(1.5 * parseInt(width.slice(0,-2))))
          var left = (screen.width/2)-(width_/2);
          var top = (screen.height/2)-(height_/2);
          var win = window.open('template.html', '_blank',
            `height=${height_}px, width=${width_}px, top=${top}px, left=${left}px`,
          );
          win.document.write(`${inner_html}`);
          win.document.close();
        }
      };
      return option;
    };option = support_popup(option=option, height="300px", width="300px", inner_html=`

            <html lang="en" style="height: 100%; text-align: -webkit-center; align-content: center">
            <title>MoCharts</title>
            <head> <meta charset="utf-8"> </head>
            <body style="height: 100%; margin: 0">
        
        
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.5.0/echarts.min.js"><\/script>
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/echarts-gl/2.0.8/echarts-gl.min.js"><\/script>
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"><\/script>
                <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/echarts-wordcloud@2.1.0/dist/echarts-wordcloud.min.js"><\/script>
            

            <div id="1742883545.20966770.4056" style="height: 90%; width: 90%"></div>
            <script type="text/javascript">
                var dom = document.getElementById('1742883545.20966770.4056');
                var myChart = echarts.init(dom, null, {
                    renderer: 'canvas',
                    useDirtyRect: false
                    });
                var app = {};

                var option;
            option = {"chart_id": "1742883545.20966770.4056", "link_id": null, "figname": "", "title": null, "grid": {"show": true, "width": "auto", "height": "auto", "z": 2, "left": "5%", "top": "10%", "right": "10%", "bottom": "5%", "borderColor": "#ccc", "borderWidth": 1, "containLabel": true, "backgroundColor": "transparent", "changed_name_key": {"id_": "id"}}, "legend": null, "brush": null, "yAxis": [{"show": true, "type": "category", "position": "bottom", "name": "", "nameLocation": "center", "nameTextStyle": {"color": "#747475", "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "nameGap": "auto", "inverse": true, "splitNumber": 5, "logBase": 10, "axisLine": {}, "axisTick": {"show": true, "alignWithLabel": "none", "interval": "auto", "length": 5}, "axisLabel": {"show": true, "margin": 8, "showMinLabel": true, "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "transparent", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "...", "width": 15.0}, "splitLine": {"show": true, "interval": "auto"}, "splitArea": {"show": false, "interval": "auto"}, "axisPointer": {"show": false}, "dimension": "2d", "ignored": false, "changed_name_key": {"min_": "min", "max_": "max", "type_": "type", "name_": "name"}}], "xAxis": [{"show": true, "type": "category", "position": "bottom", "name": "", "nameLocation": "center", "nameTextStyle": {"color": "#747475", "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "nameGap": 20, "splitNumber": 5, "logBase": 10, "axisLine": {}, "axisTick": {"show": true, "alignWithLabel": "none", "interval": "auto", "length": 5}, "axisLabel": {"show": true, "margin": 8, "showMinLabel": true, "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "transparent", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "...", "width": null}, "splitLine": {"show": true, "interval": "auto"}, "splitArea": {"show": false, "interval": "auto"}, "axisPointer": {"show": false}, "dimension": "2d", "ignored": false, "changed_name_key": {"min_": "min", "max_": "max", "type_": "type", "name_": "name"}}], "parallelAxis": null, "series": [{"type": "heatmap", "name": "heatmap", "colorBy": "series", "z": 2, "legendHoverLink": true, "stackStrategy": "samesign", "cursor": "pointer", "clip": true, "label": {"show": false, "fontSize": 12}, "seriesLayoutBy": "column", "data": [[0, 0, 0.27237584323602104], [0, 1, 0.13796798265975174], [0, 2, 0.30793283623667933], [0, 3, 0.9989549488183307], [0, 4, 0.4314442491757442], [0, 5, 0.26013057248496474], [0, 6, 0.6869341247123241], [0, 7, 0.3245408895678229], [0, 8, 0.1258890159466004], [0, 9, 0.8818753300414314], [0, 10, 0.3325556440402112], [0, 11, 0.700805210836502], [1, 0, 0.5185634768778254], [1, 1, 0.3898332998243985], [1, 2, 0.4617398373114501], [1, 3, 0.1824183902876092], [1, 4, 0.8088947193342724], [1, 5, 0.9645409836780747], [1, 6, 0.16600815858115436], [1, 7, 0.19337814335262438], [1, 8, 0.02811281094761231], [1, 9, 0.45066987592920205], [1, 10, 0.6747926627454269], [1, 11, 0.35751614759199213], [2, 0, 0.07471073163075859], [2, 1, 0.8608367628469993], [2, 2, 0.35581671051846875], [2, 3, 0.868695050519757], [2, 4, 0.17680594890972168], [2, 5, 0.09009777615745984], [2, 6, 0.9090551456216258], [2, 7, 0.7252431430480203], [2, 8, 0.35224525017257646], [2, 9, 0.26985928277264426], [2, 10, 0.10163751047016556], [2, 11, 0.5051672936415349], [3, 0, 0.005511109434659822], [3, 1, 0.8730904668206754], [3, 2, 0.294181087635465], [3, 3, 0.8741599715026078], [3, 4, 0.35795199408788736], [3, 5, 0.4045245968333433], [3, 6, 0.6190307865724818], [3, 7, 0.3606034872071845], [3, 8, 0.6013848673673315], [3, 9, 0.1868771453429936], [3, 10, 0.9486686559988898], [3, 11, 0.47426147309562117], [4, 0, 0.7364853303183831], [4, 1, 0.46810587432003525], [4, 2, 0.42378729392305525], [4, 3, 0.709262833041649], [4, 4, 0.5106172178092351], [4, 5, 0.29757122055843044], [4, 6, 0.8468997441531542], [4, 7, 0.6133222431968983], [4, 8, 0.7271622317739226], [4, 9, 0.3274293399613677], [4, 10, 0.05730557931865332], [4, 11, 0.03501106117933639], [5, 0, 0.18809014294462134], [5, 1, 0.14190334876945132], [5, 2, 0.43521377917387705], [5, 3, 0.1071318346759903], [5, 4, 0.5784224722383547], [5, 5, 0.88409922553051], [5, 6, 0.9241900827852525], [5, 7, 0.4492599479626087], [5, 8, 0.920748592607004], [5, 9, 0.8642344821458507], [5, 10, 0.12203185275410178], [5, 11, 0.258949311965436], [6, 0, 0.7279787444243998], [6, 1, 0.23384975747294323], [6, 2, 0.5566685762432702], [6, 3, 0.3191988097949767], [6, 4, 0.3484252636009233], [6, 5, 0.9445842924282806], [6, 6, 0.3909090453934262], [6, 7, 0.7398794851021748], [6, 8, 0.8138195406763531], [6, 9, 0.9857228624500285], [6, 10, 0.6114281174760708], [6, 11, 0.9655319663802195], [7, 0, 0.5325890469095058], [7, 1, 0.20349285367767433], [7, 2, 0.9667397413083247], [7, 3, 0.5264870474572312], [7, 4, 0.9474805307102734], [7, 5, 0.10090629199986834], [7, 6, 0.8746851441116414], [7, 7, 0.24240035580105979], [7, 8, 0.6651446894829596], [7, 9, 0.5564958145767985], [7, 10, 0.7604909439438715], [7, 11, 0.9295256137638989], [8, 0, 0.14116838459546976], [8, 1, 0.9400521589330242], [8, 2, 0.36966408895210867], [8, 3, 0.9609988722516355], [8, 4, 0.910377793312877], [8, 5, 0.6976189009125657], [8, 6, 0.9436371307582052], [8, 7, 0.3192951021028464], [8, 8, 0.05556427068616665], [8, 9, 0.3119283501744635], [8, 10, 0.5701990954907886], [8, 11, 0.934609830994786], [9, 0, 0.5117145989767983], [9, 1, 0.7406340707495557], [9, 2, 0.032886090326281536], [9, 3, 0.7002179608573725], [9, 4, 0.15120392753450485], [9, 5, 0.5515193523252402], [9, 6, 0.050443129711200796], [9, 7, 0.9656108691422916], [9, 8, 0.48319278717716285], [9, 9, 0.06620887738044512], [9, 10, 0.444715304964857], [9, 11, 0.40691846987010827]], "animation": true, "animationThreshold": 2000, "animationDuration": 1000, "animationEasing": "cubicOut", "animationDurationUpdate": 300, "animationEasingUpdate": "cubicOut", "coordinateSystem": "cartesian2d", "pointSize": 20, "blurSize": 10, "maxOpacity": 1, "progressive": 400, "progressiveThreshold": 3000, "colsize": 1, "visualmap_type": "continuous", "map_range": [0.005511109434659822, 0.9989549488183307]}], "visualMap": {"show": true, "type": "continuous", "color": ["#440154", "#481467", "#482576", "#453781", "#404688", "#39558c", "#33638d", "#2d718e", "#287d8e", "#238a8d", "#1f968b", "#20a386", "#29af7f", "#3dbc74", "#56c667", "#75d054", "#95d840", "#bade28", "#dde318", "#fde725"], "left": "auto", "top": "10%", "right": "1%", "bottom": "auto", "min": 0.005511109434659822, "max": 0.9989549488183307, "calculable": false, "realtime": true, "precision": 2, "itemWidth": 20, "itemHeight": 560, "align": "auto", "textGap": 10, "hoverLink": true, "z": 4, "padding": 0, "backgroundColor": "rgba(0,0,0,0)", "borderColor": "#ccc", "textStyle": {"fontSize": 12, "width": 35, "overflow": "none", "ellipsis": ".."}, "indicatorSize": "50%", "orient": "vertical", "changed_name_key": {"id_": "id", "type_": "type", "min_": "min", "max_": "max", "range_": "range"}}, "toolbox": {"show": true, "orient": "horizontal", "itemSize": 30, "itemGap": 8, "showTitle": true, "feature": {"dataZoom": {}, "saveAsImage": {}}, "z": 2, "left": "7%", "top": "auto", "right": "1%", "bottom": "auto", "width": "auto", "height": "auto", "popup": true, "changed_name_key": {"id_": "id"}}, "tooltip": null, "dataZoom": null, "event": null, "graphic": null, "radar": null, "figsize": {"height": 300, "width": 300}, "color": ["#1f77b4", "#ff7f0e", "#2ca02c", "#e377c2", "#9467bd", "#d62728", "#8c564b", "#bcbd22", "#17becf", "#7f7f7f"], "save_img": false, "auto_size": true, "style": {"overflow": "auto"}, "port": "5005"};function setInnerHTML(elm, html) {
      elm.innerHTML = html;
  
      Array.from(elm.querySelectorAll("script"))
        .forEach( oldScriptEl => {
          const newScriptEl = document.createElement("script");
      
          Array.from(oldScriptEl.attributes).forEach( attr => {
            newScriptEl.setAttribute(attr.name, attr.value) 
          });
      
          const scriptText = document.createTextNode(oldScriptEl.innerHTML);
          newScriptEl.appendChild(scriptText);
      
          oldScriptEl.parentNode.replaceChild(newScriptEl, oldScriptEl);
      });
    };

    function getScreenSize(option) {
      let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_result_save', {
            method: 'post',
            headers: {
              'Content-Type': 'application/json;charset=utf-8;',
              'Access-Control-Allow-Origin':'*',
              'Access-Control-Allow-Credentials': 'true',
              'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
            },
            body: JSON.stringify({'js_func_input':{'height': screen.height, 'width': screen.width},
                                  'event_id': 'screen_size'})
          });
          fetch(testRequest).then(response => {});
      return 
    }
    function support_scientific_notation(option) {
      if (Array.isArray(option['yAxis'])) {
        for (var tar_ind = 0; tar_ind < option['yAxis'].length; tar_ind++) {
          if (option['yAxis'][tar_ind]['type'] === 'value') {
            option['yAxis'][tar_ind]['axisLabel']['formatter'] = function(val) {
              const superscripts = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹','¹⁰',
                        '¹¹', '¹²', '¹³', '¹⁴', '¹⁵', '¹⁶', '¹⁷', '¹⁸', '¹⁹','²⁰',
                        '²¹', '²²', '²³', '²⁴', '²⁵', '²⁶', '²⁷', '²⁸', '²⁹'];
              function toSuperscript(val) {
                if (val.toString().length > 5 && !val.toString().includes('.')) {
                  val = Number(val).toExponential().toString();
                  if (val.includes('-')) {
                    val = val.split('-');
                    var val0 = val[0];
                    var val1 = superscripts[val[1]];
                    return val0 + '⁻' + val1
                  }
                  else if (val.includes('+')) {
                    val = val.split('+');
                    var val0 = val[0];
                    var val1 = superscripts[val[1]];
                    return val0 + '⁺' + val1
                  }
                }
                else {
                  return val
                }
              }
              return toSuperscript(val)
            }
          }
        }
      }
      else {
        if (option['yAxis']['type'] === 'value') {
          option['yAxis']['axisLabel']['formatter'] = function(val) {
            const superscripts = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹','¹⁰',
                    '¹¹', '¹²', '¹³', '¹⁴', '¹⁵', '¹⁶', '¹⁷', '¹⁸', '¹⁹','²⁰',
                    '²¹', '²²', '²³', '²⁴', '²⁵', '²⁶', '²⁷', '²⁸', '²⁹'];
            function toSuperscript(val) {
              if (val.toString().length > 5 && !val.toString().includes('.')) {
                val = Number(val).toExponential().toString();
                if (val.includes('-')) {
                  val = val.split('-');
                  var val0 = val[0];
                  var val1 = superscripts[val[1]];
                  return val0 + '⁻' + val1
                }
                else if (val.includes('+')) {
                  val = val.split('+');
                  var val0 = val[0];
                  var val1 = superscripts[val[1]];
                  return val0 + '⁺' + val1
                }
              }
              else {
                return val
              }
            }
            return toSuperscript(val)
          }
        }
      };
      return option;
    };

    function auto_component_size(option) {
      if (typeof option['figsize']['width'] === 'string' || option['figsize']['width'] instanceof String) {
        if (option['figsize']['width'].includes('%')) {
          var width = 800 * (parseFloat(option['figsize']['width'].slice(0,-1)) / 100);
        }
        else if (option['figsize']['width'].includes('px')) {
          var width = parseFloat(option['figsize']['width'].slice(0,-2));
        }
      }
      else {
        var width = option['figsize']['width']
      }

      if (typeof option['figsize']['height'] === 'string' || option['figsize']['height'] instanceof String) {
        if (option['figsize']['height'].includes('%')) {
          var height = 600 * (parseFloat(option['figsize']['height'].slice(0,-1)) / 100);
        }
        else if (option['figsize']['height'].includes('px')) {
          var height = parseFloat(option['figsize']['height'].slice(0,-2));
        }
      }
      else {
        var height = option['figsize']['height']
      }

      var relative_ratio = Math.min(width / 700, height / 400)
      if ('xAxis3D' in option) {
        var keys = ['xAxis3D', 'yAxis3D', 'zAxis3D']
      }
      else {
        var keys = ['xAxis', 'yAxis']
      }
      for (single_key of keys) {
        for (var ind = 0; ind < option[single_key].length; ind++) {
          option[single_key][ind]['nameTextStyle']['fontSize'] = Math.max(7, option[single_key][ind]['nameTextStyle']['fontSize'] * relative_ratio);
          option[single_key][ind]['axisLabel']['fontSize'] = Math.max(7, option[single_key][ind]['axisLabel']['fontSize'] * relative_ratio);
        }
      }
      if (option['series']) {
        for (var ind = 0; ind < option['series'].length; ind++) {
          if (['heatmap', 'bar'].includes(option['series'][ind]['type'])) {
            if (option['series'][ind]['label']) {
              option['series'][ind]['label']['fontSize'] = Math.max(7, option['series'][ind]['label']['fontSize'] * relative_ratio);
            }
          }
        }
      }
      if (option['title']) {
        if (Array.isArray(option['title'])) {
          for (var ind = 0; ind < option['title'].length; ind++) {
            option['title'][ind]['textStyle']['fontSize'] = Math.max(9, option['title'][ind]['textStyle']['fontSize'] * relative_ratio);
          }
        }
        else {
          option['title']['textStyle']['fontSize'] = Math.max(9, option['title']['textStyle']['fontSize'] * relative_ratio);
        }
      }
      if (option['legend']) {
        option['legend']['itemHeight'] = option['legend']['itemHeight'] * relative_ratio;
        option['legend']['itemWidth'] = option['legend']['itemWidth'] * relative_ratio;
        option['legend']['textStyle']['fontSize'] = Math.max(7, option['legend']['textStyle']['fontSize'] * relative_ratio);
      }
      if (option['visualMap']) {
        option['visualMap']['itemHeight'] = option['visualMap']['itemHeight'] * relative_ratio;
        option['visualMap']['itemWidth'] = option['visualMap']['itemWidth'] * relative_ratio;
        option['visualMap']['textStyle']['fontSize'] = Math.max(7, option['visualMap']['textStyle']['fontSize'] * relative_ratio);
      }
      if (option['toolbox']) {
        option['toolbox']['itemSize'] = Math.max(8, option['toolbox']['itemSize'] * relative_ratio)
        option['toolbox']['itemGap'] = Math.max(4, option['toolbox']['itemGap'] * relative_ratio);
      }
      if (option['graphic']) {
        for (var ind = 0; ind < option['graphic'].length; ind++) {
          for (var ind2 = 0; ind2 < option['graphic'][ind]['children'].length; ind2++) {
            var new_font = Math.max(7, 12 * relative_ratio);
            option['graphic'][ind]['children'][ind2]['style']['font'] = new_font.toString() + 'px Microsoft YaHei';
          }
        }
      }
      return option;
    }

    function save_img(echarts_instance, option) {
      const base64_str = echarts_instance.getDataURL({
          pixelRatio: 2,
          backgroundColor: '#fff',
          width: option['figsize']['width'],
          height: option['figsize']['height']
      });

      let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_image_save', {
        method: 'post',
        headers: {
          'Content-Type': 'application/json;charset=utf-8;',
          'Access-Control-Allow-Origin':'*',
          'Access-Control-Allow-Credentials': 'true',
          'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
        },
        body: JSON.stringify({'figname': option['figname'],
                              'base64_str': base64_str})
      });
      fetch(testRequest).then(response => {});
    };


    function auto_axis_namegap(echarts_instance, auto_axis_list, axis_type) {
      const globalModel = echarts_instance._api.getModel()
      const figsize = globalModel.option.figsize
      const ctx = document.createElement('canvas').getContext('2d')
      if (typeof globalModel.option['figsize']['width'] === 'string' || globalModel.option['figsize']['width'] instanceof String) {
        if (globalModel.option['figsize']['width'].includes('%')) {
          var width = 800 * (parseFloat(globalModel.option['figsize']['width'].slice(0,-1)) / 100);
        }
        else if (globalModel.option['figsize']['width'].includes('px')) {
          var width = parseFloat(globalModel.option['figsize']['width'].slice(0,-2));
        }
      }
      else {
        var width = globalModel.option['figsize']['width'];
      }

      if (typeof globalModel.option['figsize']['height'] === 'string' || globalModel.option['figsize']['height'] instanceof String) {
        if (globalModel.option['figsize']['height'].includes('%')) {
          var height = 600 * (parseFloat(globalModel.option['figsize']['height'].slice(0,-1)) / 100);
        }
        else if (globalModel.option['figsize']['height'].includes('px')) {
          var height = parseFloat(globalModel.option['figsize']['height'].slice(0,-2));
        }
      }
      else {
        var height = option['figsize']['height'];
      }
      var relative_ratio = Math.min(width / 700, height / 400);
      if (axis_type==='2d') {
        const yAxisList = globalModel.option.yAxis
        const xAxisList = globalModel.option.xAxis

        for (var axis_idx of auto_axis_list) {
          const yAxis = yAxisList[axis_idx]
          const fontSize = yAxis.nameTextStyle?.fontSize ?? 12
          const fontFamily = yAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
          ctx.save()
          ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
  
          const yAxisComponent = globalModel.getComponent('yAxis', axis_idx)?.axis
          if (yAxis.type === 'value') {
            var labelMaxWidth = Math.min(Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
          }
          else {
            var labelMaxWidth = Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
          }
          var axisLabelMargin = yAxis.axisLabel?.margin ?? 8
          axisLabelMargin = axisLabelMargin * relative_ratio
          yAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
          ctx.restore()
        };
  
        for (var axis_idx of [...Array(xAxisList.length).keys()]) {
          var new_gap = Math.max(xAxisList[axis_idx].nameGap * relative_ratio, 12);
          if (figsize['height'] < 400) {
            new_gap = Math.min(20, new_gap);
          }
          xAxisList[axis_idx].nameGap = new_gap;
        }
  
        echarts_instance.setOption({
          yAxis: yAxisList,
          xAxis: xAxisList
        })
      }
      else {
        const yAxisList = globalModel.option.yAxis3D
        const xAxisList = globalModel.option.xAxis3D
        const zAxisList = globalModel.option.zAxis3D

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < xAxisList.length) {
            const xAxis = xAxisList[axis_idx]
            const fontSize = xAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = xAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const xAxisComponent = globalModel.getComponent('xAxis3D', axis_idx)?.axis
            if (xAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...xAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...xAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = xAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            xAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < yAxisList.length) {
            const yAxis = yAxisList[axis_idx]
            const fontSize = yAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = yAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const yAxisComponent = globalModel.getComponent('yAxis3D', axis_idx)?.axis
            if (yAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = yAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            yAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < zAxisList.length) {
            const zAxis = zAxisList[axis_idx]
            const fontSize = zAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = zAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const zAxisComponent = globalModel.getComponent('zAxis3D', axis_idx)?.axis
            if (zAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...zAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...zAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = zAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            zAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };
        echarts_instance.setOption({
          yAxis3D: yAxisList,
          xAxis3D: xAxisList,
          zAxis3D: zAxisList
        });
        }
  
    };

    function custom_scatter_size(option) {
  
      for (var ind = 0; ind < option['series'].length; ind++) {
        if (option['series'][ind]['symbolSize'] === 'array_size') {
          var ind_ = option['series'][ind]['data_dict']['size']
          option['series'][ind]['symbolSize'] = function (data) {return data[ind_];}
        }
      }
      return option;
  
    };

    function show_scatter_label(option) {
  
      for (var ind = 0; ind < option['series'].length; ind++) {
        if (option['series'][ind]['label'] === 'show_label') {
          var ind_ = option['series'][ind]['data_dict']['label']
          option['series'][ind]['label'] = {
            show: true,
            formatter: function (params) {return params.data.value[ind_]; }
          }
        }
      }
      return option;
    };

    function hide_min_max_axis_label(option) {
      for (var ind = 0; ind < option['xAxis3D'].length; ind++) {
        if (option['xAxis3D'][ind]['type'] == 'value') {
          var x_min = option['xAxis3D'][ind]['min']
          var x_max = option['xAxis3D'][ind]['max']
          option['xAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==x_min || value==x_max){}
            else {return value}
          }
        }
      }
      for (var ind = 0; ind < option['yAxis3D'].length; ind++) {
        if (option['yAxis3D'][ind]['type'] == 'value') {  
          var y_min = option['yAxis3D'][ind]['min']
          var y_max = option['yAxis3D'][ind]['max']
          option['yAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==y_min || value==y_max){}
            else {return value}
          }
        }
      }
      for (var ind = 0; ind < option['zAxis3D'].length; ind++) {
        if (option['zAxis3D'][ind]['type'] == 'value') {
          var z_min = option['zAxis3D'][ind]['min']
          var z_max = option['zAxis3D'][ind]['max']
          option['zAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==z_min || value==z_max){}
            else {return value}
          }
       }
      }
      return option;
    }

    function custom_axis_label(option) {
      if (Array.isArray(option['xAxis'])) {
        for (var ind = 0; ind < option['xAxis'].length; ind++) {
          if (option['xAxis'][ind]['axisLabel']['formatter_func']) {
            var f = new Function(option['xAxis'][ind]['axisLabel']['formatter_func'].arguments,
                                 option['xAxis'][ind]['axisLabel']['formatter_func'].body)
            option['xAxis'][ind]['axisLabel']['formatter'] = f
          }
        }
      }
      else {
        if (option['xAxis']['axisLabel']['formatter_func']) {
          var f = new Function(option['xAxis']['axisLabel']['formatter_func'].arguments,
                               option['xAxis']['axisLabel']['formatter_func'].body)
          option['xAxis']['axisLabel']['formatter'] = f
        }
      }
      if (Array.isArray(option['yAxis'])) {
        for (var ind = 0; ind < option['yAxis'].length; ind++) {
          if (option['yAxis'][ind]['axisLabel']['formatter_func']) {
            var f = new Function(option['yAxis'][ind]['axisLabel']['formatter_func'].arguments,
                                 option['yAxis'][ind]['axisLabel']['formatter_func'].body)
            option['yAxis'][ind]['axisLabel']['formatter'] = f
          }
        }
      }
      else {
        if (option['yAxis']['axisLabel']['formatter_func']) {
          var f = new Function(option['yAxis']['axisLabel']['formatter_func'].arguments,
                               option['yAxis']['axisLabel']['formatter_func'].body)
          option['yAxis']['axisLabel']['formatter'] = f
        }
      }
      return option;
    }

    function custom_tooltip(option, dimension=2) {

      if (dimension === 2) {
        var xaxis_key = 'xAxis'
        var yaxis_key = 'yAxis'
      }

      else if (dimension === 3) {
        var xaxis_key = 'xAxis3D'
        var yaxis_key = 'yAxis3D'
        var zaxis_key = 'zAxis3D'
      }

      if (option['radar']) {
        var radar_names = []
        for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
          radar_names.push(option['radar']['indicator'][ind_]['name']) 
        }
      }
  
  
      if (option[xaxis_key]['name'] !== null && option[xaxis_key]['name'] !== '' && Array.isArray(option[xaxis_key])!==true) {
        var xaxis_name = option[xaxis_key]['name'];
      }
      else {
        var xaxis_name = 'X';
      }

      if (option[yaxis_key]['name'] !== null && option[yaxis_key]['name'] !== ''&& Array.isArray(option[xaxis_key])!==true) {
        var yaxis_name = option[yaxis_key]['name'];
      }
      else {
        var yaxis_name = 'Y';
      }

      if (typeof zaxis_key !== 'undefined') {
        if (option[zaxis_key]['name'] !== ''&& Array.isArray(option[xaxis_key])!==true) {
          var zaxis_name = option[zaxis_key]['name'];
        }
        else {
          var zaxis_name = 'Z';
        }
      }
  
      if (option['tooltip']) {
        if (option['tooltip']['precision']) {
          var precision = option['tooltip']['precision']
          option['tooltip']['valueFormatter'] = (value) =>  Math.round(Number(value) * (10**precision)) / (10**precision)
        }

        for (var ind_ = 0; ind_ < option['series'].length; ind_++) {
          if (option['series'][ind_]['tooltip']) {
            if (option['series'][ind_]['tooltip']['precision']) {
              var precision = option['series'][ind_]['tooltip']['precision']
              const fix = precision_ => value => Math.round(Number(value) * (10**precision_)) / (10**precision_),
              fix_p = fix(precision);
              option['series'][ind_]['tooltip']['valueFormatter'] = function (value) {
                return fix_p(value)
              } 
            }
          }
        }

        if (option['series'].length === 1) {
          if (['scatter', 'heatmap', 'scatter3D', 'radar'].includes(option['series'][0]['type'])) {
            option['tooltip']['formatter'] = function(params) {
              if (params.seriesName.includes('series')) {
                var series_name = ''
              }
          
              else {
                var series_name = params.seriesName + '<br>'
              }
      
              if (params.seriesType === 'scatter') {
                if (option['tooltip']['custom_tooltip'] === true) {
                  formatter = series_name
                    + params.value[dimension]
                }
                else {
                  formatter = series_name
                  + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                  +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                }
            
              }
  
              else if (params.seriesType === 'heatmap') {
                formatter = params.name + ', ' + option['yAxis'][0]['data'][params.data[1]] + '<br> <b>' + Math.round(params.data[2] * 10000) / 10000
              }
      
              else if (params.seriesType === 'scatter3D') {
                if (option['tooltip']['custom_tooltip'] === true) {
                  formatter = series_name
                    + params.value[dimension]
                }
                else {
                  formatter = series_name
                    + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                    +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                    +'<br>' + zaxis_name + ': ' + Math.round(params.value[2] * 100) / 100
                }
              }
          
              else if (params.seriesType === 'radar') {
                formatter = params.name  + '<br>';
                for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
                  if (ind_ !== option['radar']['indicator'].length - 1) {
                    formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100 + '<br>'
                  }
                  else {
                    formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100
                  }
                }
              }
            return formatter;
            }
          }
        }
        else {
          for (var out_ind_ = 0; out_ind_ < option['series'].length; out_ind_++) {
            if (['scatter', 'heatmap', 'scatter3D', 'radar'].includes(option['series'][out_ind_]['type'])) {
              if (option['series'][out_ind_]['tooltip']) {
              }
              else {
                option['series'][out_ind_]['tooltip'] = {}
              }
              option['series'][out_ind_]['tooltip']['formatter'] = function(params) {
                if (params.seriesName.includes('series')) {
                  var series_name = ''
                }
            
                else {
                  var series_name = params.seriesName + '<br>'
                }
        
                if (params.seriesType === 'scatter') {
                  if (option['tooltip']['custom_tooltip'] === true) {
                    formatter = series_name
                      + params.value[dimension]
                  }
                  else {
                    formatter = series_name
                      + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                      +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                  }
                }
    
                else if (params.seriesType === 'heatmap') {
                  if ('data' in option['yAxis'][option['series'][params.seriesIndex]['yAxisIndex']]) {
                    formatter = params.name + ', ' + option['yAxis'][option['series'][params.seriesIndex]['yAxisIndex']]['data'][params.data[1]] + '<br> <b>' + Math.round(params.data[2] * 10000) / 10000
                  }
                  else {
                    formatter = Math.round(params.data[2] * 10000) / 10000
                  }
                
                }
        
                else if (params.seriesType === 'scatter3D') {
                  if (option['tooltip']['custom_tooltip'] === true) {
                    formatter = series_name
                      + params.value[dimension]
                  }
                  else {
                    formatter = series_name
                      + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                      +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                      +'<br>' + zaxis_name + ': ' + Math.round(params.value[2] * 100) / 100
                  }
                }
            
                else if (params.seriesType === 'radar') {
                  formatter = params.name  + '<br>';
                  for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
                    if (ind_ !== option['radar']['indicator'].length - 1) {
                      formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100 + '<br>'
                    }
                    else {
                      formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100
                    }
                  }
                }
              return formatter;
              }
            }
          }
        }
      }
      return option;
    };

    function support_brush_event(option) {
      if (option['event']['type_'] === 'brushselected') {
        if (option['link_id'] === null) {
          var link_id = option['chart_id'];
        }
        else {
          var link_id = option['link_id'];
        }
        var dom = document.getElementById(link_id);
        var bind_chart = echarts.init(dom, null, {
            renderer: 'canvas',
            useDirtyRect: false
        });
        var last_selected = [];
        bind_chart.on(option['event']['type_'], (params) => {
          var brushed = [];
          var brushComponent = params.batch[0];
          for (var sIdx = 0; sIdx < brushComponent.selected.length; sIdx++) {
            var rawIndices = brushComponent.selected[sIdx].dataIndex;
            brushed.push(rawIndices);
          }
          var brushed_all = brushed[0];

          if (JSON.stringify(last_selected) !== JSON.stringify(brushed_all)) {

            // Update memory
            let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_call_python_function', {
              method: 'post',
              headers: {
                  'Content-Type': 'application/json;charset=utf-8;',
                  'Access-Control-Allow-Origin':'*',
                  'Access-Control-Allow-Credentials': 'true',
                  'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
              },
              body: JSON.stringify({'js_func_input':{'selected': brushed_all},
                                    'event_id': option['event']['event_id']})
            });
            var dom_dict = {}
            fetch(testRequest).then(response => {
              var result = response.json();
              result.then(res => {
                dom_dict[res['link_id']] = document.getElementById(res['link_id']);
                setInnerHTML(dom_dict[res['link_id']], res['html']);
              });
            });
            last_selected = brushed_all;
          }
                            
        // bind_chart.setOption(option);
        })
      }
      return option;
    };

    function support_click_event(option) {
      if (option['event']['type_'] === 'click') {
        if (option['link_id'] === null) {
          var link_id = option['chart_id'];
        }
        else {
          var link_id = option['link_id'];
        }
        var dom = document.getElementById(link_id);
        var bind_chart = echarts.init(dom, null, {
            renderer: 'canvas',
            useDirtyRect: false
        });

        if (option['series'][0]['orient'] === 'vertical') {
          var value_idx = 0
        }
        else {
          var value_idx = 1
        }
    

        bind_chart.on(option['event']['type_'], (params) => {
          if (option['event']['task'] === 'singleselect') {
            for (var ind_2 = 0; ind_2 < option['series'][0]['data'].length; ind_2++) {
              if (option['series'][0]['data'][ind_2]['itemStyle']['color'] !== '#1f77b4') {
                option['series'][0]['data'][ind_2]['itemStyle']['color'] = '#1f77b4';
              }
            }
            var idx = option['series'][0]['x_value'].indexOf(params.value[value_idx])
            option['series'][0]['data'][idx]['itemStyle']['color'] = '#ff7f0e';

            var selected = params.value[value_idx];
          }
          else {
            console.log(params);
          }
      
          let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_call_python_function', {
            method: 'post',
            headers: {
              'Content-Type': 'application/json;charset=utf-8;',
              'Access-Control-Allow-Origin':'*',
              'Access-Control-Allow-Credentials': 'true',
              'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
            },
            body: JSON.stringify({'js_func_input':{'selected': selected},
                                  'event_id': option['event']['event_id']})
          });
          var dom_dict = {}
          fetch(testRequest).then(response => {
            var result = response.json();
            result.then(res => {
              dom_dict[res['link_id']] = document.getElementById(res['link_id']);
              setInnerHTML(dom_dict[res['link_id']], res['html']);
            });
          });
          bind_chart.setOption(option);
        });
      }
      return option;
    };option = support_scientific_notation(option=option);option = custom_tooltip(option=option, dimension=2);option = custom_axis_label(option=option);option = auto_component_size(option=option);getScreenSize(option=option);

                myChart.setOption(option);
                window.addEventListener('resize', function () {
                    myChart.resize();
                    var option_copy = JSON.parse(JSON.stringify(option));
                    option_copy['figsize']['height'] = myChart.getHeight();
                    option_copy['figsize']['width'] = myChart.getWidth();
                    // option_copy = auto_component_size(option_copy);
                    myChart.setOption(option_copy);
                });
            <\/script>
            </body>
            </html>
        <style>
    .dg.main.taller-than-window .close-button {
        border-top: 1px solid #ddd;
    }

    .dg.main .close-button {
        background-color: #e8e8e8;
    }
 
    .dg.main .close-button:hover {
        background-color: #ddd;
    }

    .dg {
        color: #555;
        text-shadow: none !important;
    }

    .dg.main::-webkit-scrollbar {
        background: #fafafa;
    }

    .dg.main::-webkit-scrollbar-thumb {
        background: #bbb;
    }
 
    .dg li:not(.folder) {
        background: #fafafa;
        border-bottom: 1px solid #ddd;
    }
 
    .dg li.save-row .button {
        text-shadow: none !important;
    }

    .dg li.title {
        background: #e8e8e8 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;
    }

    .dg .cr.function:hover,.dg .cr.boolean:hover {
        background: #fff;
    }
 
    .dg .c input[type=text] {
        background: #e9e9e9;
    }
 
    .dg .c input[type=text]:hover {
        background: #eee;
    }
 
    .dg .c input[type=text]:focus {
        background: #eee;
        color: #555;
    }
 
    .dg .c .slider {
        background: #e9e9e9;
    }

    .dg .c .slider:hover {
        background: #eee;
    }<\/style>`);option = support_scientific_notation(option=option);option = custom_tooltip(option=option, dimension=2);option = custom_axis_label(option=option);option = auto_component_size(option=option);getScreenSize(option=option);

                if (option && typeof option === 'object') {
                    myChart.setOption(option);
                    }

                auto_axis_namegap(echarts_instance=myChart, auto_axis_list=[0], axis_type="2d");

            </script>
            </body>
            </html>
    
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 31-32

Custom Heatmap Plot

.. GENERATED FROM PYTHON SOURCE LINES 32-41

.. code-block:: Python

    uniform_data = np.round(np.random.rand(10, 12), 3)
    hm = mc.heatmap(data=uniform_data, extent=[0, 1, 0, 1], show_label=True)
    hm.set_visualmap(calculable=True)
    hm.set_xaxis(axis_name='x')
    hm.set_yaxis(axis_name='y')
    hm.set_title('Heatmap')
    hm.set_figsize((4,4))
    # hm.show()
    HTML(hm.show(return_html=True, silent=True))





.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">

                <!DOCTYPE html>
                <html lang="en" style="height: 100%">
                <head>
                <meta charset="utf-8">
                </head>
                <body style="height: 100%; margin: 0">

            
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.5.0/echarts.min.js"></script>
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/echarts-gl/2.0.8/echarts-gl.min.js"></script>
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
                <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/echarts-wordcloud@2.1.0/dist/echarts-wordcloud.min.js"></script>
            
                <div id="1742883545.21566720.9596" style="height: 400px; width: 400px; overflow: auto"></div>
            
                <script type="text/javascript">
                var dom = document.getElementById('1742883545.21566720.9596');
                dom.innerHTML = ""
                dom.setAttribute('_echarts_instance_', '')
                var myChart = echarts.init(dom, null, {
                    renderer: 'canvas',
                    useDirtyRect: false
                    });
                var app = {};

                var option;
        option = {"chart_id": "1742883545.21566720.9596", "link_id": null, "figname": "", "title": {"show": true, "text": "Heatmap", "link": "", "target": "blank", "textStyle": {"fontStyle": "normal", "fontWeight": "bolder", "fontFamily": "sans-serif", "fontSize": 15, "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "subtext": "", "sublink": "", "subtarget": "blank", "textAlign": "center", "textVerticalAlign": "auto", "padding": 0, "itemGap": 10, "z": 2, "left": "50.0%", "top": "5%", "right": "auto", "bottom": "auto", "backgroundColor": "transparent", "borderColor": "#ccc", "changed_name_key": {"id_": "id"}}, "grid": {"show": true, "width": "auto", "height": "auto", "z": 2, "left": "5%", "top": "10%", "right": "10%", "bottom": "5%", "borderColor": "#ccc", "borderWidth": 1, "containLabel": true, "backgroundColor": "transparent", "changed_name_key": {"id_": "id"}}, "legend": null, "brush": null, "yAxis": [{"show": true, "data": [0.0, 0.09091, 0.1818, 0.2727, 0.3636, 0.4545, 0.5455, 0.6364, 0.7273, 0.8182, 0.9091, 1.0], "type": "category", "position": "bottom", "name": "y", "nameLocation": "center", "nameTextStyle": {"color": "#747475", "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "nameGap": "auto", "inverse": true, "splitNumber": 5, "logBase": 10, "axisLine": {}, "axisTick": {"show": true, "alignWithLabel": "none", "interval": "auto", "length": 5}, "axisLabel": {"show": true, "interval": 3, "margin": 8, "showMinLabel": true, "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "transparent", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "...", "width": 20.0}, "splitLine": {"show": true, "interval": "auto"}, "splitArea": {"show": false, "interval": "auto"}, "axisPointer": {"show": false}, "dimension": "2d", "ignored": false, "changed_name_key": {"min_": "min", "max_": "max", "type_": "type", "name_": "name"}}], "xAxis": [{"show": true, "data": [0.0, 0.1111, 0.2222, 0.3333, 0.4444, 0.5556, 0.6667, 0.7778, 0.8889, 1.0], "type": "category", "position": "bottom", "name": "x", "nameLocation": "center", "nameTextStyle": {"color": "#747475", "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "nameGap": 30, "splitNumber": 5, "logBase": 10, "axisLine": {}, "axisTick": {"show": true, "alignWithLabel": "none", "interval": "auto", "length": 5}, "axisLabel": {"show": true, "interval": 2, "margin": 8, "showMinLabel": true, "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "transparent", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "...", "width": null}, "splitLine": {"show": true, "interval": "auto"}, "splitArea": {"show": false, "interval": "auto"}, "axisPointer": {"show": false}, "dimension": "2d", "ignored": false, "changed_name_key": {"min_": "min", "max_": "max", "type_": "type", "name_": "name"}}], "parallelAxis": null, "series": [{"type": "heatmap", "name": "heatmap", "colorBy": "series", "z": 2, "legendHoverLink": true, "stackStrategy": "samesign", "cursor": "pointer", "clip": true, "label": {"show": true, "fontSize": 12}, "seriesLayoutBy": "column", "data": [[0, 0, 0.827], [0, 1, 0.768], [0, 2, 0.331], [0, 3, 0.587], [0, 4, 0.928], [0, 5, 0.603], [0, 6, 0.62], [0, 7, 0.273], [0, 8, 0.618], [0, 9, 0.329], [0, 10, 0.029], [0, 11, 0.436], [1, 0, 0.133], [1, 1, 0.658], [1, 2, 0.161], [1, 3, 0.399], [1, 4, 0.172], [1, 5, 0.691], [1, 6, 0.328], [1, 7, 0.35], [1, 8, 0.351], [1, 9, 0.69], [1, 10, 0.353], [1, 11, 0.65], [2, 0, 0.139], [2, 1, 0.618], [2, 2, 0.615], [2, 3, 0.615], [2, 4, 0.207], [2, 5, 0.186], [2, 6, 0.238], [2, 7, 0.371], [2, 8, 0.155], [2, 9, 0.122], [2, 10, 0.116], [2, 11, 0.257], [3, 0, 0.534], [3, 1, 0.991], [3, 2, 0.027], [3, 3, 0.204], [3, 4, 0.463], [3, 5, 0.801], [3, 6, 0.657], [3, 7, 0.466], [3, 8, 0.546], [3, 9, 0.928], [3, 10, 0.323], [3, 11, 0.047], [4, 0, 0.383], [4, 1, 0.722], [4, 2, 0.944], [4, 3, 0.334], [4, 4, 0.145], [4, 5, 0.639], [4, 6, 0.202], [4, 7, 0.243], [4, 8, 0.643], [4, 9, 0.214], [4, 10, 0.936], [4, 11, 0.082], [5, 0, 0.486], [5, 1, 0.482], [5, 2, 0.81], [5, 3, 0.356], [5, 4, 0.842], [5, 5, 0.71], [5, 6, 0.901], [5, 7, 0.632], [5, 8, 0.067], [5, 9, 0.709], [5, 10, 0.691], [5, 11, 0.053], [6, 0, 0.312], [6, 1, 0.088], [6, 2, 0.736], [6, 3, 0.027], [6, 4, 0.097], [6, 5, 0.669], [6, 6, 0.601], [6, 7, 0.816], [6, 8, 0.662], [6, 9, 0.85], [6, 10, 0.107], [6, 11, 0.864], [7, 0, 0.622], [7, 1, 0.971], [7, 2, 0.259], [7, 3, 0.767], [7, 4, 0.032], [7, 5, 0.427], [7, 6, 0.822], [7, 7, 0.457], [7, 8, 0.222], [7, 9, 0.441], [7, 10, 0.068], [7, 11, 0.251], [8, 0, 0.049], [8, 1, 0.488], [8, 2, 0.086], [8, 3, 0.155], [8, 4, 0.808], [8, 5, 0.342], [8, 6, 0.881], [8, 7, 0.126], [8, 8, 0.207], [8, 9, 0.692], [8, 10, 0.974], [8, 11, 0.783], [9, 0, 0.385], [9, 1, 0.199], [9, 2, 0.418], [9, 3, 0.602], [9, 4, 0.782], [9, 5, 0.041], [9, 6, 0.524], [9, 7, 0.589], [9, 8, 0.725], [9, 9, 0.32], [9, 10, 0.85], [9, 11, 0.115]], "animation": true, "animationThreshold": 2000, "animationDuration": 1000, "animationEasing": "cubicOut", "animationDurationUpdate": 300, "animationEasingUpdate": "cubicOut", "coordinateSystem": "cartesian2d", "pointSize": 20, "blurSize": 10, "maxOpacity": 1, "progressive": 400, "progressiveThreshold": 3000, "colsize": 1, "extent": [0, 1, 0, 1], "visualmap_type": "continuous", "map_range": [0.027, 0.991]}], "visualMap": {"show": true, "type": "continuous", "color": ["#440154", "#481467", "#482576", "#453781", "#404688", "#39558c", "#33638d", "#2d718e", "#287d8e", "#238a8d", "#1f968b", "#20a386", "#29af7f", "#3dbc74", "#56c667", "#75d054", "#95d840", "#bade28", "#dde318", "#fde725"], "left": "auto", "top": "10%", "right": "1%", "bottom": "auto", "min": 0.027, "max": 0.991, "calculable": true, "realtime": true, "precision": 2, "itemWidth": 20, "itemHeight": 140, "align": "auto", "textGap": 10, "hoverLink": true, "z": 4, "padding": 0, "backgroundColor": "rgba(0,0,0,0)", "borderColor": "#ccc", "textStyle": {"fontSize": 12, "width": 35, "overflow": "none", "ellipsis": ".."}, "indicatorSize": "50%", "orient": "vertical", "changed_name_key": {"id_": "id", "type_": "type", "min_": "min", "max_": "max", "range_": "range"}}, "toolbox": {"show": true, "orient": "horizontal", "itemSize": 15, "itemGap": 8, "showTitle": true, "feature": {"dataZoom": {}, "saveAsImage": {}}, "z": 2, "left": "auto", "top": "auto", "right": "1%", "bottom": "auto", "width": "auto", "height": "auto", "popup": true, "changed_name_key": {"id_": "id"}}, "tooltip": null, "dataZoom": null, "event": null, "graphic": null, "radar": null, "figsize": {"height": 400, "width": 400}, "color": ["#1f77b4", "#ff7f0e", "#2ca02c", "#e377c2", "#9467bd", "#d62728", "#8c564b", "#bcbd22", "#17becf", "#7f7f7f"], "save_img": false, "auto_size": true, "style": {"overflow": "auto"}, "port": "5005"};function setInnerHTML(elm, html) {
      elm.innerHTML = html;
  
      Array.from(elm.querySelectorAll("script"))
        .forEach( oldScriptEl => {
          const newScriptEl = document.createElement("script");
      
          Array.from(oldScriptEl.attributes).forEach( attr => {
            newScriptEl.setAttribute(attr.name, attr.value) 
          });
      
          const scriptText = document.createTextNode(oldScriptEl.innerHTML);
          newScriptEl.appendChild(scriptText);
      
          oldScriptEl.parentNode.replaceChild(newScriptEl, oldScriptEl);
      });
    };

    function getScreenSize(option) {
      let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_result_save', {
            method: 'post',
            headers: {
              'Content-Type': 'application/json;charset=utf-8;',
              'Access-Control-Allow-Origin':'*',
              'Access-Control-Allow-Credentials': 'true',
              'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
            },
            body: JSON.stringify({'js_func_input':{'height': screen.height, 'width': screen.width},
                                  'event_id': 'screen_size'})
          });
          fetch(testRequest).then(response => {});
      return 
    }
    function support_scientific_notation(option) {
      if (Array.isArray(option['yAxis'])) {
        for (var tar_ind = 0; tar_ind < option['yAxis'].length; tar_ind++) {
          if (option['yAxis'][tar_ind]['type'] === 'value') {
            option['yAxis'][tar_ind]['axisLabel']['formatter'] = function(val) {
              const superscripts = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹','¹⁰',
                        '¹¹', '¹²', '¹³', '¹⁴', '¹⁵', '¹⁶', '¹⁷', '¹⁸', '¹⁹','²⁰',
                        '²¹', '²²', '²³', '²⁴', '²⁵', '²⁶', '²⁷', '²⁸', '²⁹'];
              function toSuperscript(val) {
                if (val.toString().length > 5 && !val.toString().includes('.')) {
                  val = Number(val).toExponential().toString();
                  if (val.includes('-')) {
                    val = val.split('-');
                    var val0 = val[0];
                    var val1 = superscripts[val[1]];
                    return val0 + '⁻' + val1
                  }
                  else if (val.includes('+')) {
                    val = val.split('+');
                    var val0 = val[0];
                    var val1 = superscripts[val[1]];
                    return val0 + '⁺' + val1
                  }
                }
                else {
                  return val
                }
              }
              return toSuperscript(val)
            }
          }
        }
      }
      else {
        if (option['yAxis']['type'] === 'value') {
          option['yAxis']['axisLabel']['formatter'] = function(val) {
            const superscripts = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹','¹⁰',
                    '¹¹', '¹²', '¹³', '¹⁴', '¹⁵', '¹⁶', '¹⁷', '¹⁸', '¹⁹','²⁰',
                    '²¹', '²²', '²³', '²⁴', '²⁵', '²⁶', '²⁷', '²⁸', '²⁹'];
            function toSuperscript(val) {
              if (val.toString().length > 5 && !val.toString().includes('.')) {
                val = Number(val).toExponential().toString();
                if (val.includes('-')) {
                  val = val.split('-');
                  var val0 = val[0];
                  var val1 = superscripts[val[1]];
                  return val0 + '⁻' + val1
                }
                else if (val.includes('+')) {
                  val = val.split('+');
                  var val0 = val[0];
                  var val1 = superscripts[val[1]];
                  return val0 + '⁺' + val1
                }
              }
              else {
                return val
              }
            }
            return toSuperscript(val)
          }
        }
      };
      return option;
    };

    function auto_component_size(option) {
      if (typeof option['figsize']['width'] === 'string' || option['figsize']['width'] instanceof String) {
        if (option['figsize']['width'].includes('%')) {
          var width = 800 * (parseFloat(option['figsize']['width'].slice(0,-1)) / 100);
        }
        else if (option['figsize']['width'].includes('px')) {
          var width = parseFloat(option['figsize']['width'].slice(0,-2));
        }
      }
      else {
        var width = option['figsize']['width']
      }

      if (typeof option['figsize']['height'] === 'string' || option['figsize']['height'] instanceof String) {
        if (option['figsize']['height'].includes('%')) {
          var height = 600 * (parseFloat(option['figsize']['height'].slice(0,-1)) / 100);
        }
        else if (option['figsize']['height'].includes('px')) {
          var height = parseFloat(option['figsize']['height'].slice(0,-2));
        }
      }
      else {
        var height = option['figsize']['height']
      }

      var relative_ratio = Math.min(width / 700, height / 400)
      if ('xAxis3D' in option) {
        var keys = ['xAxis3D', 'yAxis3D', 'zAxis3D']
      }
      else {
        var keys = ['xAxis', 'yAxis']
      }
      for (single_key of keys) {
        for (var ind = 0; ind < option[single_key].length; ind++) {
          option[single_key][ind]['nameTextStyle']['fontSize'] = Math.max(7, option[single_key][ind]['nameTextStyle']['fontSize'] * relative_ratio);
          option[single_key][ind]['axisLabel']['fontSize'] = Math.max(7, option[single_key][ind]['axisLabel']['fontSize'] * relative_ratio);
        }
      }
      if (option['series']) {
        for (var ind = 0; ind < option['series'].length; ind++) {
          if (['heatmap', 'bar'].includes(option['series'][ind]['type'])) {
            if (option['series'][ind]['label']) {
              option['series'][ind]['label']['fontSize'] = Math.max(7, option['series'][ind]['label']['fontSize'] * relative_ratio);
            }
          }
        }
      }
      if (option['title']) {
        if (Array.isArray(option['title'])) {
          for (var ind = 0; ind < option['title'].length; ind++) {
            option['title'][ind]['textStyle']['fontSize'] = Math.max(9, option['title'][ind]['textStyle']['fontSize'] * relative_ratio);
          }
        }
        else {
          option['title']['textStyle']['fontSize'] = Math.max(9, option['title']['textStyle']['fontSize'] * relative_ratio);
        }
      }
      if (option['legend']) {
        option['legend']['itemHeight'] = option['legend']['itemHeight'] * relative_ratio;
        option['legend']['itemWidth'] = option['legend']['itemWidth'] * relative_ratio;
        option['legend']['textStyle']['fontSize'] = Math.max(7, option['legend']['textStyle']['fontSize'] * relative_ratio);
      }
      if (option['visualMap']) {
        option['visualMap']['itemHeight'] = option['visualMap']['itemHeight'] * relative_ratio;
        option['visualMap']['itemWidth'] = option['visualMap']['itemWidth'] * relative_ratio;
        option['visualMap']['textStyle']['fontSize'] = Math.max(7, option['visualMap']['textStyle']['fontSize'] * relative_ratio);
      }
      if (option['toolbox']) {
        option['toolbox']['itemSize'] = Math.max(8, option['toolbox']['itemSize'] * relative_ratio)
        option['toolbox']['itemGap'] = Math.max(4, option['toolbox']['itemGap'] * relative_ratio);
      }
      if (option['graphic']) {
        for (var ind = 0; ind < option['graphic'].length; ind++) {
          for (var ind2 = 0; ind2 < option['graphic'][ind]['children'].length; ind2++) {
            var new_font = Math.max(7, 12 * relative_ratio);
            option['graphic'][ind]['children'][ind2]['style']['font'] = new_font.toString() + 'px Microsoft YaHei';
          }
        }
      }
      return option;
    }

    function save_img(echarts_instance, option) {
      const base64_str = echarts_instance.getDataURL({
          pixelRatio: 2,
          backgroundColor: '#fff',
          width: option['figsize']['width'],
          height: option['figsize']['height']
      });

      let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_image_save', {
        method: 'post',
        headers: {
          'Content-Type': 'application/json;charset=utf-8;',
          'Access-Control-Allow-Origin':'*',
          'Access-Control-Allow-Credentials': 'true',
          'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
        },
        body: JSON.stringify({'figname': option['figname'],
                              'base64_str': base64_str})
      });
      fetch(testRequest).then(response => {});
    };


    function auto_axis_namegap(echarts_instance, auto_axis_list, axis_type) {
      const globalModel = echarts_instance._api.getModel()
      const figsize = globalModel.option.figsize
      const ctx = document.createElement('canvas').getContext('2d')
      if (typeof globalModel.option['figsize']['width'] === 'string' || globalModel.option['figsize']['width'] instanceof String) {
        if (globalModel.option['figsize']['width'].includes('%')) {
          var width = 800 * (parseFloat(globalModel.option['figsize']['width'].slice(0,-1)) / 100);
        }
        else if (globalModel.option['figsize']['width'].includes('px')) {
          var width = parseFloat(globalModel.option['figsize']['width'].slice(0,-2));
        }
      }
      else {
        var width = globalModel.option['figsize']['width'];
      }

      if (typeof globalModel.option['figsize']['height'] === 'string' || globalModel.option['figsize']['height'] instanceof String) {
        if (globalModel.option['figsize']['height'].includes('%')) {
          var height = 600 * (parseFloat(globalModel.option['figsize']['height'].slice(0,-1)) / 100);
        }
        else if (globalModel.option['figsize']['height'].includes('px')) {
          var height = parseFloat(globalModel.option['figsize']['height'].slice(0,-2));
        }
      }
      else {
        var height = option['figsize']['height'];
      }
      var relative_ratio = Math.min(width / 700, height / 400);
      if (axis_type==='2d') {
        const yAxisList = globalModel.option.yAxis
        const xAxisList = globalModel.option.xAxis

        for (var axis_idx of auto_axis_list) {
          const yAxis = yAxisList[axis_idx]
          const fontSize = yAxis.nameTextStyle?.fontSize ?? 12
          const fontFamily = yAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
          ctx.save()
          ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
  
          const yAxisComponent = globalModel.getComponent('yAxis', axis_idx)?.axis
          if (yAxis.type === 'value') {
            var labelMaxWidth = Math.min(Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
          }
          else {
            var labelMaxWidth = Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
          }
          var axisLabelMargin = yAxis.axisLabel?.margin ?? 8
          axisLabelMargin = axisLabelMargin * relative_ratio
          yAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
          ctx.restore()
        };
  
        for (var axis_idx of [...Array(xAxisList.length).keys()]) {
          var new_gap = Math.max(xAxisList[axis_idx].nameGap * relative_ratio, 12);
          if (figsize['height'] < 400) {
            new_gap = Math.min(20, new_gap);
          }
          xAxisList[axis_idx].nameGap = new_gap;
        }
  
        echarts_instance.setOption({
          yAxis: yAxisList,
          xAxis: xAxisList
        })
      }
      else {
        const yAxisList = globalModel.option.yAxis3D
        const xAxisList = globalModel.option.xAxis3D
        const zAxisList = globalModel.option.zAxis3D

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < xAxisList.length) {
            const xAxis = xAxisList[axis_idx]
            const fontSize = xAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = xAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const xAxisComponent = globalModel.getComponent('xAxis3D', axis_idx)?.axis
            if (xAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...xAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...xAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = xAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            xAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < yAxisList.length) {
            const yAxis = yAxisList[axis_idx]
            const fontSize = yAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = yAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const yAxisComponent = globalModel.getComponent('yAxis3D', axis_idx)?.axis
            if (yAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = yAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            yAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < zAxisList.length) {
            const zAxis = zAxisList[axis_idx]
            const fontSize = zAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = zAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const zAxisComponent = globalModel.getComponent('zAxis3D', axis_idx)?.axis
            if (zAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...zAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...zAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = zAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            zAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };
        echarts_instance.setOption({
          yAxis3D: yAxisList,
          xAxis3D: xAxisList,
          zAxis3D: zAxisList
        });
        }
  
    };

    function custom_scatter_size(option) {
  
      for (var ind = 0; ind < option['series'].length; ind++) {
        if (option['series'][ind]['symbolSize'] === 'array_size') {
          var ind_ = option['series'][ind]['data_dict']['size']
          option['series'][ind]['symbolSize'] = function (data) {return data[ind_];}
        }
      }
      return option;
  
    };

    function show_scatter_label(option) {
  
      for (var ind = 0; ind < option['series'].length; ind++) {
        if (option['series'][ind]['label'] === 'show_label') {
          var ind_ = option['series'][ind]['data_dict']['label']
          option['series'][ind]['label'] = {
            show: true,
            formatter: function (params) {return params.data.value[ind_]; }
          }
        }
      }
      return option;
    };

    function hide_min_max_axis_label(option) {
      for (var ind = 0; ind < option['xAxis3D'].length; ind++) {
        if (option['xAxis3D'][ind]['type'] == 'value') {
          var x_min = option['xAxis3D'][ind]['min']
          var x_max = option['xAxis3D'][ind]['max']
          option['xAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==x_min || value==x_max){}
            else {return value}
          }
        }
      }
      for (var ind = 0; ind < option['yAxis3D'].length; ind++) {
        if (option['yAxis3D'][ind]['type'] == 'value') {  
          var y_min = option['yAxis3D'][ind]['min']
          var y_max = option['yAxis3D'][ind]['max']
          option['yAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==y_min || value==y_max){}
            else {return value}
          }
        }
      }
      for (var ind = 0; ind < option['zAxis3D'].length; ind++) {
        if (option['zAxis3D'][ind]['type'] == 'value') {
          var z_min = option['zAxis3D'][ind]['min']
          var z_max = option['zAxis3D'][ind]['max']
          option['zAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==z_min || value==z_max){}
            else {return value}
          }
       }
      }
      return option;
    }

    function custom_axis_label(option) {
      if (Array.isArray(option['xAxis'])) {
        for (var ind = 0; ind < option['xAxis'].length; ind++) {
          if (option['xAxis'][ind]['axisLabel']['formatter_func']) {
            var f = new Function(option['xAxis'][ind]['axisLabel']['formatter_func'].arguments,
                                 option['xAxis'][ind]['axisLabel']['formatter_func'].body)
            option['xAxis'][ind]['axisLabel']['formatter'] = f
          }
        }
      }
      else {
        if (option['xAxis']['axisLabel']['formatter_func']) {
          var f = new Function(option['xAxis']['axisLabel']['formatter_func'].arguments,
                               option['xAxis']['axisLabel']['formatter_func'].body)
          option['xAxis']['axisLabel']['formatter'] = f
        }
      }
      if (Array.isArray(option['yAxis'])) {
        for (var ind = 0; ind < option['yAxis'].length; ind++) {
          if (option['yAxis'][ind]['axisLabel']['formatter_func']) {
            var f = new Function(option['yAxis'][ind]['axisLabel']['formatter_func'].arguments,
                                 option['yAxis'][ind]['axisLabel']['formatter_func'].body)
            option['yAxis'][ind]['axisLabel']['formatter'] = f
          }
        }
      }
      else {
        if (option['yAxis']['axisLabel']['formatter_func']) {
          var f = new Function(option['yAxis']['axisLabel']['formatter_func'].arguments,
                               option['yAxis']['axisLabel']['formatter_func'].body)
          option['yAxis']['axisLabel']['formatter'] = f
        }
      }
      return option;
    }

    function custom_tooltip(option, dimension=2) {

      if (dimension === 2) {
        var xaxis_key = 'xAxis'
        var yaxis_key = 'yAxis'
      }

      else if (dimension === 3) {
        var xaxis_key = 'xAxis3D'
        var yaxis_key = 'yAxis3D'
        var zaxis_key = 'zAxis3D'
      }

      if (option['radar']) {
        var radar_names = []
        for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
          radar_names.push(option['radar']['indicator'][ind_]['name']) 
        }
      }
  
  
      if (option[xaxis_key]['name'] !== null && option[xaxis_key]['name'] !== '' && Array.isArray(option[xaxis_key])!==true) {
        var xaxis_name = option[xaxis_key]['name'];
      }
      else {
        var xaxis_name = 'X';
      }

      if (option[yaxis_key]['name'] !== null && option[yaxis_key]['name'] !== ''&& Array.isArray(option[xaxis_key])!==true) {
        var yaxis_name = option[yaxis_key]['name'];
      }
      else {
        var yaxis_name = 'Y';
      }

      if (typeof zaxis_key !== 'undefined') {
        if (option[zaxis_key]['name'] !== ''&& Array.isArray(option[xaxis_key])!==true) {
          var zaxis_name = option[zaxis_key]['name'];
        }
        else {
          var zaxis_name = 'Z';
        }
      }
  
      if (option['tooltip']) {
        if (option['tooltip']['precision']) {
          var precision = option['tooltip']['precision']
          option['tooltip']['valueFormatter'] = (value) =>  Math.round(Number(value) * (10**precision)) / (10**precision)
        }

        for (var ind_ = 0; ind_ < option['series'].length; ind_++) {
          if (option['series'][ind_]['tooltip']) {
            if (option['series'][ind_]['tooltip']['precision']) {
              var precision = option['series'][ind_]['tooltip']['precision']
              const fix = precision_ => value => Math.round(Number(value) * (10**precision_)) / (10**precision_),
              fix_p = fix(precision);
              option['series'][ind_]['tooltip']['valueFormatter'] = function (value) {
                return fix_p(value)
              } 
            }
          }
        }

        if (option['series'].length === 1) {
          if (['scatter', 'heatmap', 'scatter3D', 'radar'].includes(option['series'][0]['type'])) {
            option['tooltip']['formatter'] = function(params) {
              if (params.seriesName.includes('series')) {
                var series_name = ''
              }
          
              else {
                var series_name = params.seriesName + '<br>'
              }
      
              if (params.seriesType === 'scatter') {
                if (option['tooltip']['custom_tooltip'] === true) {
                  formatter = series_name
                    + params.value[dimension]
                }
                else {
                  formatter = series_name
                  + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                  +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                }
            
              }
  
              else if (params.seriesType === 'heatmap') {
                formatter = params.name + ', ' + option['yAxis'][0]['data'][params.data[1]] + '<br> <b>' + Math.round(params.data[2] * 10000) / 10000
              }
      
              else if (params.seriesType === 'scatter3D') {
                if (option['tooltip']['custom_tooltip'] === true) {
                  formatter = series_name
                    + params.value[dimension]
                }
                else {
                  formatter = series_name
                    + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                    +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                    +'<br>' + zaxis_name + ': ' + Math.round(params.value[2] * 100) / 100
                }
              }
          
              else if (params.seriesType === 'radar') {
                formatter = params.name  + '<br>';
                for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
                  if (ind_ !== option['radar']['indicator'].length - 1) {
                    formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100 + '<br>'
                  }
                  else {
                    formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100
                  }
                }
              }
            return formatter;
            }
          }
        }
        else {
          for (var out_ind_ = 0; out_ind_ < option['series'].length; out_ind_++) {
            if (['scatter', 'heatmap', 'scatter3D', 'radar'].includes(option['series'][out_ind_]['type'])) {
              if (option['series'][out_ind_]['tooltip']) {
              }
              else {
                option['series'][out_ind_]['tooltip'] = {}
              }
              option['series'][out_ind_]['tooltip']['formatter'] = function(params) {
                if (params.seriesName.includes('series')) {
                  var series_name = ''
                }
            
                else {
                  var series_name = params.seriesName + '<br>'
                }
        
                if (params.seriesType === 'scatter') {
                  if (option['tooltip']['custom_tooltip'] === true) {
                    formatter = series_name
                      + params.value[dimension]
                  }
                  else {
                    formatter = series_name
                      + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                      +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                  }
                }
    
                else if (params.seriesType === 'heatmap') {
                  if ('data' in option['yAxis'][option['series'][params.seriesIndex]['yAxisIndex']]) {
                    formatter = params.name + ', ' + option['yAxis'][option['series'][params.seriesIndex]['yAxisIndex']]['data'][params.data[1]] + '<br> <b>' + Math.round(params.data[2] * 10000) / 10000
                  }
                  else {
                    formatter = Math.round(params.data[2] * 10000) / 10000
                  }
                
                }
        
                else if (params.seriesType === 'scatter3D') {
                  if (option['tooltip']['custom_tooltip'] === true) {
                    formatter = series_name
                      + params.value[dimension]
                  }
                  else {
                    formatter = series_name
                      + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                      +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                      +'<br>' + zaxis_name + ': ' + Math.round(params.value[2] * 100) / 100
                  }
                }
            
                else if (params.seriesType === 'radar') {
                  formatter = params.name  + '<br>';
                  for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
                    if (ind_ !== option['radar']['indicator'].length - 1) {
                      formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100 + '<br>'
                    }
                    else {
                      formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100
                    }
                  }
                }
              return formatter;
              }
            }
          }
        }
      }
      return option;
    };

    function support_brush_event(option) {
      if (option['event']['type_'] === 'brushselected') {
        if (option['link_id'] === null) {
          var link_id = option['chart_id'];
        }
        else {
          var link_id = option['link_id'];
        }
        var dom = document.getElementById(link_id);
        var bind_chart = echarts.init(dom, null, {
            renderer: 'canvas',
            useDirtyRect: false
        });
        var last_selected = [];
        bind_chart.on(option['event']['type_'], (params) => {
          var brushed = [];
          var brushComponent = params.batch[0];
          for (var sIdx = 0; sIdx < brushComponent.selected.length; sIdx++) {
            var rawIndices = brushComponent.selected[sIdx].dataIndex;
            brushed.push(rawIndices);
          }
          var brushed_all = brushed[0];

          if (JSON.stringify(last_selected) !== JSON.stringify(brushed_all)) {

            // Update memory
            let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_call_python_function', {
              method: 'post',
              headers: {
                  'Content-Type': 'application/json;charset=utf-8;',
                  'Access-Control-Allow-Origin':'*',
                  'Access-Control-Allow-Credentials': 'true',
                  'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
              },
              body: JSON.stringify({'js_func_input':{'selected': brushed_all},
                                    'event_id': option['event']['event_id']})
            });
            var dom_dict = {}
            fetch(testRequest).then(response => {
              var result = response.json();
              result.then(res => {
                dom_dict[res['link_id']] = document.getElementById(res['link_id']);
                setInnerHTML(dom_dict[res['link_id']], res['html']);
              });
            });
            last_selected = brushed_all;
          }
                            
        // bind_chart.setOption(option);
        })
      }
      return option;
    };

    function support_click_event(option) {
      if (option['event']['type_'] === 'click') {
        if (option['link_id'] === null) {
          var link_id = option['chart_id'];
        }
        else {
          var link_id = option['link_id'];
        }
        var dom = document.getElementById(link_id);
        var bind_chart = echarts.init(dom, null, {
            renderer: 'canvas',
            useDirtyRect: false
        });

        if (option['series'][0]['orient'] === 'vertical') {
          var value_idx = 0
        }
        else {
          var value_idx = 1
        }
    

        bind_chart.on(option['event']['type_'], (params) => {
          if (option['event']['task'] === 'singleselect') {
            for (var ind_2 = 0; ind_2 < option['series'][0]['data'].length; ind_2++) {
              if (option['series'][0]['data'][ind_2]['itemStyle']['color'] !== '#1f77b4') {
                option['series'][0]['data'][ind_2]['itemStyle']['color'] = '#1f77b4';
              }
            }
            var idx = option['series'][0]['x_value'].indexOf(params.value[value_idx])
            option['series'][0]['data'][idx]['itemStyle']['color'] = '#ff7f0e';

            var selected = params.value[value_idx];
          }
          else {
            console.log(params);
          }
      
          let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_call_python_function', {
            method: 'post',
            headers: {
              'Content-Type': 'application/json;charset=utf-8;',
              'Access-Control-Allow-Origin':'*',
              'Access-Control-Allow-Credentials': 'true',
              'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
            },
            body: JSON.stringify({'js_func_input':{'selected': selected},
                                  'event_id': option['event']['event_id']})
          });
          var dom_dict = {}
          fetch(testRequest).then(response => {
            var result = response.json();
            result.then(res => {
              dom_dict[res['link_id']] = document.getElementById(res['link_id']);
              setInnerHTML(dom_dict[res['link_id']], res['html']);
            });
          });
          bind_chart.setOption(option);
        });
      }
      return option;
    };function support_popup(option, height, width, inner_html) {
      option['toolbox']['feature']['myFeature'] = {
        show: true,
        title: 'Open in new window',
        icon: "image://data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iNDhweCIgd2lkdGg9IjQ4cHgiIHZpZXdCb3g9IjE2MCAtODAwIDY0MCA2NDAiIGZpbGw9IiM2NjY2NjYiPg0KICA8cGF0aCBkPSJNMjE1LjM4LTE2MHEtMjMuMDUgMC0zOS4yMi0xNi4xNlExNjAtMTkyLjMzIDE2MC0yMTUuMzh2LTUyOS4yNHEwLTIzLjA1IDE2LjE2LTM5LjIyUTE5Mi4zMy04MDAgMjE1LjM4LTgwMGgyMjQuMzl2MzAuNzdIMjE1LjM4cS05LjIzIDAtMTYuOTIgNy42OS03LjY5IDcuNjktNy42OSAxNi45MnY1MjkuMjRxMCA5LjIzIDcuNjkgMTYuOTIgNy42OSA3LjY5IDE2LjkyIDcuNjloNTI5LjI0cTkuMjMgMCAxNi45Mi03LjY5IDcuNjktNy42OSA3LjY5LTE2Ljkydi0yMjQuMzlIODAwdjIyNC4zOXEwIDIzLjA1LTE2LjE2IDM5LjIyUTc2Ny42Ny0xNjAgNzQ0LjYyLTE2MEgyMTUuMzhabTE3MS4yNC0yMDQuMzgtMjItMjIuMjQgMzgyLjYxLTM4Mi42MUg1NDEuMzFWLTgwMEg4MDB2MjU4LjY5aC0zMC43N1YtNzQ3TDM4Ni42Mi0zNjQuMzhaIi8+DQo8L3N2Zz4NCg==",
        onclick: function (){
          var height_ = Math.min(screen.height, Math.round(1.5 * parseInt(height.slice(0,-2))))
          var width_ = Math.min(screen.width, Math.round(1.5 * parseInt(width.slice(0,-2))))
          var left = (screen.width/2)-(width_/2);
          var top = (screen.height/2)-(height_/2);
          var win = window.open('template.html', '_blank',
            `height=${height_}px, width=${width_}px, top=${top}px, left=${left}px`,
          );
          win.document.write(`${inner_html}`);
          win.document.close();
        }
      };
      return option;
    };option = support_popup(option=option, height="400px", width="400px", inner_html=`

            <html lang="en" style="height: 100%; text-align: -webkit-center; align-content: center">
            <title>MoCharts</title>
            <head> <meta charset="utf-8"> </head>
            <body style="height: 100%; margin: 0">
        
        
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.5.0/echarts.min.js"><\/script>
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/echarts-gl/2.0.8/echarts-gl.min.js"><\/script>
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"><\/script>
                <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/echarts-wordcloud@2.1.0/dist/echarts-wordcloud.min.js"><\/script>
            

            <div id="1742883545.21566720.9596" style="height: 90%; width: 90%"></div>
            <script type="text/javascript">
                var dom = document.getElementById('1742883545.21566720.9596');
                var myChart = echarts.init(dom, null, {
                    renderer: 'canvas',
                    useDirtyRect: false
                    });
                var app = {};

                var option;
            option = {"chart_id": "1742883545.21566720.9596", "link_id": null, "figname": "", "title": {"show": true, "text": "Heatmap", "link": "", "target": "blank", "textStyle": {"fontStyle": "normal", "fontWeight": "bolder", "fontFamily": "sans-serif", "fontSize": 15, "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "subtext": "", "sublink": "", "subtarget": "blank", "textAlign": "center", "textVerticalAlign": "auto", "padding": 0, "itemGap": 10, "z": 2, "left": "50.0%", "top": "5%", "right": "auto", "bottom": "auto", "backgroundColor": "transparent", "borderColor": "#ccc", "changed_name_key": {"id_": "id"}}, "grid": {"show": true, "width": "auto", "height": "auto", "z": 2, "left": "5%", "top": "10%", "right": "10%", "bottom": "5%", "borderColor": "#ccc", "borderWidth": 1, "containLabel": true, "backgroundColor": "transparent", "changed_name_key": {"id_": "id"}}, "legend": null, "brush": null, "yAxis": [{"show": true, "data": [0.0, 0.09091, 0.1818, 0.2727, 0.3636, 0.4545, 0.5455, 0.6364, 0.7273, 0.8182, 0.9091, 1.0], "type": "category", "position": "bottom", "name": "y", "nameLocation": "center", "nameTextStyle": {"color": "#747475", "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "nameGap": "auto", "inverse": true, "splitNumber": 5, "logBase": 10, "axisLine": {}, "axisTick": {"show": true, "alignWithLabel": "none", "interval": "auto", "length": 5}, "axisLabel": {"show": true, "interval": 3, "margin": 8, "showMinLabel": true, "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "transparent", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "...", "width": 20.0}, "splitLine": {"show": true, "interval": "auto"}, "splitArea": {"show": false, "interval": "auto"}, "axisPointer": {"show": false}, "dimension": "2d", "ignored": false, "changed_name_key": {"min_": "min", "max_": "max", "type_": "type", "name_": "name"}}], "xAxis": [{"show": true, "data": [0.0, 0.1111, 0.2222, 0.3333, 0.4444, 0.5556, 0.6667, 0.7778, 0.8889, 1.0], "type": "category", "position": "bottom", "name": "x", "nameLocation": "center", "nameTextStyle": {"color": "#747475", "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "nameGap": 30, "splitNumber": 5, "logBase": 10, "axisLine": {}, "axisTick": {"show": true, "alignWithLabel": "none", "interval": "auto", "length": 5}, "axisLabel": {"show": true, "interval": 2, "margin": 8, "showMinLabel": true, "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "transparent", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "...", "width": null}, "splitLine": {"show": true, "interval": "auto"}, "splitArea": {"show": false, "interval": "auto"}, "axisPointer": {"show": false}, "dimension": "2d", "ignored": false, "changed_name_key": {"min_": "min", "max_": "max", "type_": "type", "name_": "name"}}], "parallelAxis": null, "series": [{"type": "heatmap", "name": "heatmap", "colorBy": "series", "z": 2, "legendHoverLink": true, "stackStrategy": "samesign", "cursor": "pointer", "clip": true, "label": {"show": true, "fontSize": 12}, "seriesLayoutBy": "column", "data": [[0, 0, 0.827], [0, 1, 0.768], [0, 2, 0.331], [0, 3, 0.587], [0, 4, 0.928], [0, 5, 0.603], [0, 6, 0.62], [0, 7, 0.273], [0, 8, 0.618], [0, 9, 0.329], [0, 10, 0.029], [0, 11, 0.436], [1, 0, 0.133], [1, 1, 0.658], [1, 2, 0.161], [1, 3, 0.399], [1, 4, 0.172], [1, 5, 0.691], [1, 6, 0.328], [1, 7, 0.35], [1, 8, 0.351], [1, 9, 0.69], [1, 10, 0.353], [1, 11, 0.65], [2, 0, 0.139], [2, 1, 0.618], [2, 2, 0.615], [2, 3, 0.615], [2, 4, 0.207], [2, 5, 0.186], [2, 6, 0.238], [2, 7, 0.371], [2, 8, 0.155], [2, 9, 0.122], [2, 10, 0.116], [2, 11, 0.257], [3, 0, 0.534], [3, 1, 0.991], [3, 2, 0.027], [3, 3, 0.204], [3, 4, 0.463], [3, 5, 0.801], [3, 6, 0.657], [3, 7, 0.466], [3, 8, 0.546], [3, 9, 0.928], [3, 10, 0.323], [3, 11, 0.047], [4, 0, 0.383], [4, 1, 0.722], [4, 2, 0.944], [4, 3, 0.334], [4, 4, 0.145], [4, 5, 0.639], [4, 6, 0.202], [4, 7, 0.243], [4, 8, 0.643], [4, 9, 0.214], [4, 10, 0.936], [4, 11, 0.082], [5, 0, 0.486], [5, 1, 0.482], [5, 2, 0.81], [5, 3, 0.356], [5, 4, 0.842], [5, 5, 0.71], [5, 6, 0.901], [5, 7, 0.632], [5, 8, 0.067], [5, 9, 0.709], [5, 10, 0.691], [5, 11, 0.053], [6, 0, 0.312], [6, 1, 0.088], [6, 2, 0.736], [6, 3, 0.027], [6, 4, 0.097], [6, 5, 0.669], [6, 6, 0.601], [6, 7, 0.816], [6, 8, 0.662], [6, 9, 0.85], [6, 10, 0.107], [6, 11, 0.864], [7, 0, 0.622], [7, 1, 0.971], [7, 2, 0.259], [7, 3, 0.767], [7, 4, 0.032], [7, 5, 0.427], [7, 6, 0.822], [7, 7, 0.457], [7, 8, 0.222], [7, 9, 0.441], [7, 10, 0.068], [7, 11, 0.251], [8, 0, 0.049], [8, 1, 0.488], [8, 2, 0.086], [8, 3, 0.155], [8, 4, 0.808], [8, 5, 0.342], [8, 6, 0.881], [8, 7, 0.126], [8, 8, 0.207], [8, 9, 0.692], [8, 10, 0.974], [8, 11, 0.783], [9, 0, 0.385], [9, 1, 0.199], [9, 2, 0.418], [9, 3, 0.602], [9, 4, 0.782], [9, 5, 0.041], [9, 6, 0.524], [9, 7, 0.589], [9, 8, 0.725], [9, 9, 0.32], [9, 10, 0.85], [9, 11, 0.115]], "animation": true, "animationThreshold": 2000, "animationDuration": 1000, "animationEasing": "cubicOut", "animationDurationUpdate": 300, "animationEasingUpdate": "cubicOut", "coordinateSystem": "cartesian2d", "pointSize": 20, "blurSize": 10, "maxOpacity": 1, "progressive": 400, "progressiveThreshold": 3000, "colsize": 1, "extent": [0, 1, 0, 1], "visualmap_type": "continuous", "map_range": [0.027, 0.991]}], "visualMap": {"show": true, "type": "continuous", "color": ["#440154", "#481467", "#482576", "#453781", "#404688", "#39558c", "#33638d", "#2d718e", "#287d8e", "#238a8d", "#1f968b", "#20a386", "#29af7f", "#3dbc74", "#56c667", "#75d054", "#95d840", "#bade28", "#dde318", "#fde725"], "left": "auto", "top": "10%", "right": "1%", "bottom": "auto", "min": 0.027, "max": 0.991, "calculable": true, "realtime": true, "precision": 2, "itemWidth": 20, "itemHeight": 140, "align": "auto", "textGap": 10, "hoverLink": true, "z": 4, "padding": 0, "backgroundColor": "rgba(0,0,0,0)", "borderColor": "#ccc", "textStyle": {"fontSize": 12, "width": 35, "overflow": "none", "ellipsis": ".."}, "indicatorSize": "50%", "orient": "vertical", "changed_name_key": {"id_": "id", "type_": "type", "min_": "min", "max_": "max", "range_": "range"}}, "toolbox": {"show": true, "orient": "horizontal", "itemSize": 15, "itemGap": 8, "showTitle": true, "feature": {"dataZoom": {}, "saveAsImage": {}}, "z": 2, "left": "auto", "top": "auto", "right": "1%", "bottom": "auto", "width": "auto", "height": "auto", "popup": true, "changed_name_key": {"id_": "id"}}, "tooltip": null, "dataZoom": null, "event": null, "graphic": null, "radar": null, "figsize": {"height": 400, "width": 400}, "color": ["#1f77b4", "#ff7f0e", "#2ca02c", "#e377c2", "#9467bd", "#d62728", "#8c564b", "#bcbd22", "#17becf", "#7f7f7f"], "save_img": false, "auto_size": true, "style": {"overflow": "auto"}, "port": "5005"};function setInnerHTML(elm, html) {
      elm.innerHTML = html;
  
      Array.from(elm.querySelectorAll("script"))
        .forEach( oldScriptEl => {
          const newScriptEl = document.createElement("script");
      
          Array.from(oldScriptEl.attributes).forEach( attr => {
            newScriptEl.setAttribute(attr.name, attr.value) 
          });
      
          const scriptText = document.createTextNode(oldScriptEl.innerHTML);
          newScriptEl.appendChild(scriptText);
      
          oldScriptEl.parentNode.replaceChild(newScriptEl, oldScriptEl);
      });
    };

    function getScreenSize(option) {
      let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_result_save', {
            method: 'post',
            headers: {
              'Content-Type': 'application/json;charset=utf-8;',
              'Access-Control-Allow-Origin':'*',
              'Access-Control-Allow-Credentials': 'true',
              'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
            },
            body: JSON.stringify({'js_func_input':{'height': screen.height, 'width': screen.width},
                                  'event_id': 'screen_size'})
          });
          fetch(testRequest).then(response => {});
      return 
    }
    function support_scientific_notation(option) {
      if (Array.isArray(option['yAxis'])) {
        for (var tar_ind = 0; tar_ind < option['yAxis'].length; tar_ind++) {
          if (option['yAxis'][tar_ind]['type'] === 'value') {
            option['yAxis'][tar_ind]['axisLabel']['formatter'] = function(val) {
              const superscripts = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹','¹⁰',
                        '¹¹', '¹²', '¹³', '¹⁴', '¹⁵', '¹⁶', '¹⁷', '¹⁸', '¹⁹','²⁰',
                        '²¹', '²²', '²³', '²⁴', '²⁵', '²⁶', '²⁷', '²⁸', '²⁹'];
              function toSuperscript(val) {
                if (val.toString().length > 5 && !val.toString().includes('.')) {
                  val = Number(val).toExponential().toString();
                  if (val.includes('-')) {
                    val = val.split('-');
                    var val0 = val[0];
                    var val1 = superscripts[val[1]];
                    return val0 + '⁻' + val1
                  }
                  else if (val.includes('+')) {
                    val = val.split('+');
                    var val0 = val[0];
                    var val1 = superscripts[val[1]];
                    return val0 + '⁺' + val1
                  }
                }
                else {
                  return val
                }
              }
              return toSuperscript(val)
            }
          }
        }
      }
      else {
        if (option['yAxis']['type'] === 'value') {
          option['yAxis']['axisLabel']['formatter'] = function(val) {
            const superscripts = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹','¹⁰',
                    '¹¹', '¹²', '¹³', '¹⁴', '¹⁵', '¹⁶', '¹⁷', '¹⁸', '¹⁹','²⁰',
                    '²¹', '²²', '²³', '²⁴', '²⁵', '²⁶', '²⁷', '²⁸', '²⁹'];
            function toSuperscript(val) {
              if (val.toString().length > 5 && !val.toString().includes('.')) {
                val = Number(val).toExponential().toString();
                if (val.includes('-')) {
                  val = val.split('-');
                  var val0 = val[0];
                  var val1 = superscripts[val[1]];
                  return val0 + '⁻' + val1
                }
                else if (val.includes('+')) {
                  val = val.split('+');
                  var val0 = val[0];
                  var val1 = superscripts[val[1]];
                  return val0 + '⁺' + val1
                }
              }
              else {
                return val
              }
            }
            return toSuperscript(val)
          }
        }
      };
      return option;
    };

    function auto_component_size(option) {
      if (typeof option['figsize']['width'] === 'string' || option['figsize']['width'] instanceof String) {
        if (option['figsize']['width'].includes('%')) {
          var width = 800 * (parseFloat(option['figsize']['width'].slice(0,-1)) / 100);
        }
        else if (option['figsize']['width'].includes('px')) {
          var width = parseFloat(option['figsize']['width'].slice(0,-2));
        }
      }
      else {
        var width = option['figsize']['width']
      }

      if (typeof option['figsize']['height'] === 'string' || option['figsize']['height'] instanceof String) {
        if (option['figsize']['height'].includes('%')) {
          var height = 600 * (parseFloat(option['figsize']['height'].slice(0,-1)) / 100);
        }
        else if (option['figsize']['height'].includes('px')) {
          var height = parseFloat(option['figsize']['height'].slice(0,-2));
        }
      }
      else {
        var height = option['figsize']['height']
      }

      var relative_ratio = Math.min(width / 700, height / 400)
      if ('xAxis3D' in option) {
        var keys = ['xAxis3D', 'yAxis3D', 'zAxis3D']
      }
      else {
        var keys = ['xAxis', 'yAxis']
      }
      for (single_key of keys) {
        for (var ind = 0; ind < option[single_key].length; ind++) {
          option[single_key][ind]['nameTextStyle']['fontSize'] = Math.max(7, option[single_key][ind]['nameTextStyle']['fontSize'] * relative_ratio);
          option[single_key][ind]['axisLabel']['fontSize'] = Math.max(7, option[single_key][ind]['axisLabel']['fontSize'] * relative_ratio);
        }
      }
      if (option['series']) {
        for (var ind = 0; ind < option['series'].length; ind++) {
          if (['heatmap', 'bar'].includes(option['series'][ind]['type'])) {
            if (option['series'][ind]['label']) {
              option['series'][ind]['label']['fontSize'] = Math.max(7, option['series'][ind]['label']['fontSize'] * relative_ratio);
            }
          }
        }
      }
      if (option['title']) {
        if (Array.isArray(option['title'])) {
          for (var ind = 0; ind < option['title'].length; ind++) {
            option['title'][ind]['textStyle']['fontSize'] = Math.max(9, option['title'][ind]['textStyle']['fontSize'] * relative_ratio);
          }
        }
        else {
          option['title']['textStyle']['fontSize'] = Math.max(9, option['title']['textStyle']['fontSize'] * relative_ratio);
        }
      }
      if (option['legend']) {
        option['legend']['itemHeight'] = option['legend']['itemHeight'] * relative_ratio;
        option['legend']['itemWidth'] = option['legend']['itemWidth'] * relative_ratio;
        option['legend']['textStyle']['fontSize'] = Math.max(7, option['legend']['textStyle']['fontSize'] * relative_ratio);
      }
      if (option['visualMap']) {
        option['visualMap']['itemHeight'] = option['visualMap']['itemHeight'] * relative_ratio;
        option['visualMap']['itemWidth'] = option['visualMap']['itemWidth'] * relative_ratio;
        option['visualMap']['textStyle']['fontSize'] = Math.max(7, option['visualMap']['textStyle']['fontSize'] * relative_ratio);
      }
      if (option['toolbox']) {
        option['toolbox']['itemSize'] = Math.max(8, option['toolbox']['itemSize'] * relative_ratio)
        option['toolbox']['itemGap'] = Math.max(4, option['toolbox']['itemGap'] * relative_ratio);
      }
      if (option['graphic']) {
        for (var ind = 0; ind < option['graphic'].length; ind++) {
          for (var ind2 = 0; ind2 < option['graphic'][ind]['children'].length; ind2++) {
            var new_font = Math.max(7, 12 * relative_ratio);
            option['graphic'][ind]['children'][ind2]['style']['font'] = new_font.toString() + 'px Microsoft YaHei';
          }
        }
      }
      return option;
    }

    function save_img(echarts_instance, option) {
      const base64_str = echarts_instance.getDataURL({
          pixelRatio: 2,
          backgroundColor: '#fff',
          width: option['figsize']['width'],
          height: option['figsize']['height']
      });

      let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_image_save', {
        method: 'post',
        headers: {
          'Content-Type': 'application/json;charset=utf-8;',
          'Access-Control-Allow-Origin':'*',
          'Access-Control-Allow-Credentials': 'true',
          'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
        },
        body: JSON.stringify({'figname': option['figname'],
                              'base64_str': base64_str})
      });
      fetch(testRequest).then(response => {});
    };


    function auto_axis_namegap(echarts_instance, auto_axis_list, axis_type) {
      const globalModel = echarts_instance._api.getModel()
      const figsize = globalModel.option.figsize
      const ctx = document.createElement('canvas').getContext('2d')
      if (typeof globalModel.option['figsize']['width'] === 'string' || globalModel.option['figsize']['width'] instanceof String) {
        if (globalModel.option['figsize']['width'].includes('%')) {
          var width = 800 * (parseFloat(globalModel.option['figsize']['width'].slice(0,-1)) / 100);
        }
        else if (globalModel.option['figsize']['width'].includes('px')) {
          var width = parseFloat(globalModel.option['figsize']['width'].slice(0,-2));
        }
      }
      else {
        var width = globalModel.option['figsize']['width'];
      }

      if (typeof globalModel.option['figsize']['height'] === 'string' || globalModel.option['figsize']['height'] instanceof String) {
        if (globalModel.option['figsize']['height'].includes('%')) {
          var height = 600 * (parseFloat(globalModel.option['figsize']['height'].slice(0,-1)) / 100);
        }
        else if (globalModel.option['figsize']['height'].includes('px')) {
          var height = parseFloat(globalModel.option['figsize']['height'].slice(0,-2));
        }
      }
      else {
        var height = option['figsize']['height'];
      }
      var relative_ratio = Math.min(width / 700, height / 400);
      if (axis_type==='2d') {
        const yAxisList = globalModel.option.yAxis
        const xAxisList = globalModel.option.xAxis

        for (var axis_idx of auto_axis_list) {
          const yAxis = yAxisList[axis_idx]
          const fontSize = yAxis.nameTextStyle?.fontSize ?? 12
          const fontFamily = yAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
          ctx.save()
          ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
  
          const yAxisComponent = globalModel.getComponent('yAxis', axis_idx)?.axis
          if (yAxis.type === 'value') {
            var labelMaxWidth = Math.min(Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
          }
          else {
            var labelMaxWidth = Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
          }
          var axisLabelMargin = yAxis.axisLabel?.margin ?? 8
          axisLabelMargin = axisLabelMargin * relative_ratio
          yAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
          ctx.restore()
        };
  
        for (var axis_idx of [...Array(xAxisList.length).keys()]) {
          var new_gap = Math.max(xAxisList[axis_idx].nameGap * relative_ratio, 12);
          if (figsize['height'] < 400) {
            new_gap = Math.min(20, new_gap);
          }
          xAxisList[axis_idx].nameGap = new_gap;
        }
  
        echarts_instance.setOption({
          yAxis: yAxisList,
          xAxis: xAxisList
        })
      }
      else {
        const yAxisList = globalModel.option.yAxis3D
        const xAxisList = globalModel.option.xAxis3D
        const zAxisList = globalModel.option.zAxis3D

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < xAxisList.length) {
            const xAxis = xAxisList[axis_idx]
            const fontSize = xAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = xAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const xAxisComponent = globalModel.getComponent('xAxis3D', axis_idx)?.axis
            if (xAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...xAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...xAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = xAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            xAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < yAxisList.length) {
            const yAxis = yAxisList[axis_idx]
            const fontSize = yAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = yAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const yAxisComponent = globalModel.getComponent('yAxis3D', axis_idx)?.axis
            if (yAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = yAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            yAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < zAxisList.length) {
            const zAxis = zAxisList[axis_idx]
            const fontSize = zAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = zAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const zAxisComponent = globalModel.getComponent('zAxis3D', axis_idx)?.axis
            if (zAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...zAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...zAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = zAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            zAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };
        echarts_instance.setOption({
          yAxis3D: yAxisList,
          xAxis3D: xAxisList,
          zAxis3D: zAxisList
        });
        }
  
    };

    function custom_scatter_size(option) {
  
      for (var ind = 0; ind < option['series'].length; ind++) {
        if (option['series'][ind]['symbolSize'] === 'array_size') {
          var ind_ = option['series'][ind]['data_dict']['size']
          option['series'][ind]['symbolSize'] = function (data) {return data[ind_];}
        }
      }
      return option;
  
    };

    function show_scatter_label(option) {
  
      for (var ind = 0; ind < option['series'].length; ind++) {
        if (option['series'][ind]['label'] === 'show_label') {
          var ind_ = option['series'][ind]['data_dict']['label']
          option['series'][ind]['label'] = {
            show: true,
            formatter: function (params) {return params.data.value[ind_]; }
          }
        }
      }
      return option;
    };

    function hide_min_max_axis_label(option) {
      for (var ind = 0; ind < option['xAxis3D'].length; ind++) {
        if (option['xAxis3D'][ind]['type'] == 'value') {
          var x_min = option['xAxis3D'][ind]['min']
          var x_max = option['xAxis3D'][ind]['max']
          option['xAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==x_min || value==x_max){}
            else {return value}
          }
        }
      }
      for (var ind = 0; ind < option['yAxis3D'].length; ind++) {
        if (option['yAxis3D'][ind]['type'] == 'value') {  
          var y_min = option['yAxis3D'][ind]['min']
          var y_max = option['yAxis3D'][ind]['max']
          option['yAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==y_min || value==y_max){}
            else {return value}
          }
        }
      }
      for (var ind = 0; ind < option['zAxis3D'].length; ind++) {
        if (option['zAxis3D'][ind]['type'] == 'value') {
          var z_min = option['zAxis3D'][ind]['min']
          var z_max = option['zAxis3D'][ind]['max']
          option['zAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==z_min || value==z_max){}
            else {return value}
          }
       }
      }
      return option;
    }

    function custom_axis_label(option) {
      if (Array.isArray(option['xAxis'])) {
        for (var ind = 0; ind < option['xAxis'].length; ind++) {
          if (option['xAxis'][ind]['axisLabel']['formatter_func']) {
            var f = new Function(option['xAxis'][ind]['axisLabel']['formatter_func'].arguments,
                                 option['xAxis'][ind]['axisLabel']['formatter_func'].body)
            option['xAxis'][ind]['axisLabel']['formatter'] = f
          }
        }
      }
      else {
        if (option['xAxis']['axisLabel']['formatter_func']) {
          var f = new Function(option['xAxis']['axisLabel']['formatter_func'].arguments,
                               option['xAxis']['axisLabel']['formatter_func'].body)
          option['xAxis']['axisLabel']['formatter'] = f
        }
      }
      if (Array.isArray(option['yAxis'])) {
        for (var ind = 0; ind < option['yAxis'].length; ind++) {
          if (option['yAxis'][ind]['axisLabel']['formatter_func']) {
            var f = new Function(option['yAxis'][ind]['axisLabel']['formatter_func'].arguments,
                                 option['yAxis'][ind]['axisLabel']['formatter_func'].body)
            option['yAxis'][ind]['axisLabel']['formatter'] = f
          }
        }
      }
      else {
        if (option['yAxis']['axisLabel']['formatter_func']) {
          var f = new Function(option['yAxis']['axisLabel']['formatter_func'].arguments,
                               option['yAxis']['axisLabel']['formatter_func'].body)
          option['yAxis']['axisLabel']['formatter'] = f
        }
      }
      return option;
    }

    function custom_tooltip(option, dimension=2) {

      if (dimension === 2) {
        var xaxis_key = 'xAxis'
        var yaxis_key = 'yAxis'
      }

      else if (dimension === 3) {
        var xaxis_key = 'xAxis3D'
        var yaxis_key = 'yAxis3D'
        var zaxis_key = 'zAxis3D'
      }

      if (option['radar']) {
        var radar_names = []
        for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
          radar_names.push(option['radar']['indicator'][ind_]['name']) 
        }
      }
  
  
      if (option[xaxis_key]['name'] !== null && option[xaxis_key]['name'] !== '' && Array.isArray(option[xaxis_key])!==true) {
        var xaxis_name = option[xaxis_key]['name'];
      }
      else {
        var xaxis_name = 'X';
      }

      if (option[yaxis_key]['name'] !== null && option[yaxis_key]['name'] !== ''&& Array.isArray(option[xaxis_key])!==true) {
        var yaxis_name = option[yaxis_key]['name'];
      }
      else {
        var yaxis_name = 'Y';
      }

      if (typeof zaxis_key !== 'undefined') {
        if (option[zaxis_key]['name'] !== ''&& Array.isArray(option[xaxis_key])!==true) {
          var zaxis_name = option[zaxis_key]['name'];
        }
        else {
          var zaxis_name = 'Z';
        }
      }
  
      if (option['tooltip']) {
        if (option['tooltip']['precision']) {
          var precision = option['tooltip']['precision']
          option['tooltip']['valueFormatter'] = (value) =>  Math.round(Number(value) * (10**precision)) / (10**precision)
        }

        for (var ind_ = 0; ind_ < option['series'].length; ind_++) {
          if (option['series'][ind_]['tooltip']) {
            if (option['series'][ind_]['tooltip']['precision']) {
              var precision = option['series'][ind_]['tooltip']['precision']
              const fix = precision_ => value => Math.round(Number(value) * (10**precision_)) / (10**precision_),
              fix_p = fix(precision);
              option['series'][ind_]['tooltip']['valueFormatter'] = function (value) {
                return fix_p(value)
              } 
            }
          }
        }

        if (option['series'].length === 1) {
          if (['scatter', 'heatmap', 'scatter3D', 'radar'].includes(option['series'][0]['type'])) {
            option['tooltip']['formatter'] = function(params) {
              if (params.seriesName.includes('series')) {
                var series_name = ''
              }
          
              else {
                var series_name = params.seriesName + '<br>'
              }
      
              if (params.seriesType === 'scatter') {
                if (option['tooltip']['custom_tooltip'] === true) {
                  formatter = series_name
                    + params.value[dimension]
                }
                else {
                  formatter = series_name
                  + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                  +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                }
            
              }
  
              else if (params.seriesType === 'heatmap') {
                formatter = params.name + ', ' + option['yAxis'][0]['data'][params.data[1]] + '<br> <b>' + Math.round(params.data[2] * 10000) / 10000
              }
      
              else if (params.seriesType === 'scatter3D') {
                if (option['tooltip']['custom_tooltip'] === true) {
                  formatter = series_name
                    + params.value[dimension]
                }
                else {
                  formatter = series_name
                    + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                    +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                    +'<br>' + zaxis_name + ': ' + Math.round(params.value[2] * 100) / 100
                }
              }
          
              else if (params.seriesType === 'radar') {
                formatter = params.name  + '<br>';
                for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
                  if (ind_ !== option['radar']['indicator'].length - 1) {
                    formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100 + '<br>'
                  }
                  else {
                    formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100
                  }
                }
              }
            return formatter;
            }
          }
        }
        else {
          for (var out_ind_ = 0; out_ind_ < option['series'].length; out_ind_++) {
            if (['scatter', 'heatmap', 'scatter3D', 'radar'].includes(option['series'][out_ind_]['type'])) {
              if (option['series'][out_ind_]['tooltip']) {
              }
              else {
                option['series'][out_ind_]['tooltip'] = {}
              }
              option['series'][out_ind_]['tooltip']['formatter'] = function(params) {
                if (params.seriesName.includes('series')) {
                  var series_name = ''
                }
            
                else {
                  var series_name = params.seriesName + '<br>'
                }
        
                if (params.seriesType === 'scatter') {
                  if (option['tooltip']['custom_tooltip'] === true) {
                    formatter = series_name
                      + params.value[dimension]
                  }
                  else {
                    formatter = series_name
                      + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                      +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                  }
                }
    
                else if (params.seriesType === 'heatmap') {
                  if ('data' in option['yAxis'][option['series'][params.seriesIndex]['yAxisIndex']]) {
                    formatter = params.name + ', ' + option['yAxis'][option['series'][params.seriesIndex]['yAxisIndex']]['data'][params.data[1]] + '<br> <b>' + Math.round(params.data[2] * 10000) / 10000
                  }
                  else {
                    formatter = Math.round(params.data[2] * 10000) / 10000
                  }
                
                }
        
                else if (params.seriesType === 'scatter3D') {
                  if (option['tooltip']['custom_tooltip'] === true) {
                    formatter = series_name
                      + params.value[dimension]
                  }
                  else {
                    formatter = series_name
                      + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                      +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                      +'<br>' + zaxis_name + ': ' + Math.round(params.value[2] * 100) / 100
                  }
                }
            
                else if (params.seriesType === 'radar') {
                  formatter = params.name  + '<br>';
                  for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
                    if (ind_ !== option['radar']['indicator'].length - 1) {
                      formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100 + '<br>'
                    }
                    else {
                      formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100
                    }
                  }
                }
              return formatter;
              }
            }
          }
        }
      }
      return option;
    };

    function support_brush_event(option) {
      if (option['event']['type_'] === 'brushselected') {
        if (option['link_id'] === null) {
          var link_id = option['chart_id'];
        }
        else {
          var link_id = option['link_id'];
        }
        var dom = document.getElementById(link_id);
        var bind_chart = echarts.init(dom, null, {
            renderer: 'canvas',
            useDirtyRect: false
        });
        var last_selected = [];
        bind_chart.on(option['event']['type_'], (params) => {
          var brushed = [];
          var brushComponent = params.batch[0];
          for (var sIdx = 0; sIdx < brushComponent.selected.length; sIdx++) {
            var rawIndices = brushComponent.selected[sIdx].dataIndex;
            brushed.push(rawIndices);
          }
          var brushed_all = brushed[0];

          if (JSON.stringify(last_selected) !== JSON.stringify(brushed_all)) {

            // Update memory
            let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_call_python_function', {
              method: 'post',
              headers: {
                  'Content-Type': 'application/json;charset=utf-8;',
                  'Access-Control-Allow-Origin':'*',
                  'Access-Control-Allow-Credentials': 'true',
                  'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
              },
              body: JSON.stringify({'js_func_input':{'selected': brushed_all},
                                    'event_id': option['event']['event_id']})
            });
            var dom_dict = {}
            fetch(testRequest).then(response => {
              var result = response.json();
              result.then(res => {
                dom_dict[res['link_id']] = document.getElementById(res['link_id']);
                setInnerHTML(dom_dict[res['link_id']], res['html']);
              });
            });
            last_selected = brushed_all;
          }
                            
        // bind_chart.setOption(option);
        })
      }
      return option;
    };

    function support_click_event(option) {
      if (option['event']['type_'] === 'click') {
        if (option['link_id'] === null) {
          var link_id = option['chart_id'];
        }
        else {
          var link_id = option['link_id'];
        }
        var dom = document.getElementById(link_id);
        var bind_chart = echarts.init(dom, null, {
            renderer: 'canvas',
            useDirtyRect: false
        });

        if (option['series'][0]['orient'] === 'vertical') {
          var value_idx = 0
        }
        else {
          var value_idx = 1
        }
    

        bind_chart.on(option['event']['type_'], (params) => {
          if (option['event']['task'] === 'singleselect') {
            for (var ind_2 = 0; ind_2 < option['series'][0]['data'].length; ind_2++) {
              if (option['series'][0]['data'][ind_2]['itemStyle']['color'] !== '#1f77b4') {
                option['series'][0]['data'][ind_2]['itemStyle']['color'] = '#1f77b4';
              }
            }
            var idx = option['series'][0]['x_value'].indexOf(params.value[value_idx])
            option['series'][0]['data'][idx]['itemStyle']['color'] = '#ff7f0e';

            var selected = params.value[value_idx];
          }
          else {
            console.log(params);
          }
      
          let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_call_python_function', {
            method: 'post',
            headers: {
              'Content-Type': 'application/json;charset=utf-8;',
              'Access-Control-Allow-Origin':'*',
              'Access-Control-Allow-Credentials': 'true',
              'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
            },
            body: JSON.stringify({'js_func_input':{'selected': selected},
                                  'event_id': option['event']['event_id']})
          });
          var dom_dict = {}
          fetch(testRequest).then(response => {
            var result = response.json();
            result.then(res => {
              dom_dict[res['link_id']] = document.getElementById(res['link_id']);
              setInnerHTML(dom_dict[res['link_id']], res['html']);
            });
          });
          bind_chart.setOption(option);
        });
      }
      return option;
    };option = support_scientific_notation(option=option);option = custom_tooltip(option=option, dimension=2);option = custom_axis_label(option=option);option = auto_component_size(option=option);getScreenSize(option=option);

                myChart.setOption(option);
                window.addEventListener('resize', function () {
                    myChart.resize();
                    var option_copy = JSON.parse(JSON.stringify(option));
                    option_copy['figsize']['height'] = myChart.getHeight();
                    option_copy['figsize']['width'] = myChart.getWidth();
                    // option_copy = auto_component_size(option_copy);
                    myChart.setOption(option_copy);
                });
            <\/script>
            </body>
            </html>
        <style>
    .dg.main.taller-than-window .close-button {
        border-top: 1px solid #ddd;
    }

    .dg.main .close-button {
        background-color: #e8e8e8;
    }
 
    .dg.main .close-button:hover {
        background-color: #ddd;
    }

    .dg {
        color: #555;
        text-shadow: none !important;
    }

    .dg.main::-webkit-scrollbar {
        background: #fafafa;
    }

    .dg.main::-webkit-scrollbar-thumb {
        background: #bbb;
    }
 
    .dg li:not(.folder) {
        background: #fafafa;
        border-bottom: 1px solid #ddd;
    }
 
    .dg li.save-row .button {
        text-shadow: none !important;
    }

    .dg li.title {
        background: #e8e8e8 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;
    }

    .dg .cr.function:hover,.dg .cr.boolean:hover {
        background: #fff;
    }
 
    .dg .c input[type=text] {
        background: #e9e9e9;
    }
 
    .dg .c input[type=text]:hover {
        background: #eee;
    }
 
    .dg .c input[type=text]:focus {
        background: #eee;
        color: #555;
    }
 
    .dg .c .slider {
        background: #e9e9e9;
    }

    .dg .c .slider:hover {
        background: #eee;
    }<\/style>`);option = support_scientific_notation(option=option);option = custom_tooltip(option=option, dimension=2);option = custom_axis_label(option=option);option = auto_component_size(option=option);getScreenSize(option=option);

                if (option && typeof option === 'object') {
                    myChart.setOption(option);
                    }

                auto_axis_namegap(echarts_instance=myChart, auto_axis_list=[0], axis_type="2d");

            </script>
            </body>
            </html>
    
    </div>
    <br />
    <br />


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.013 seconds)


.. _sphx_glr_download__source_auto_galleries_galleries_plots_plots_0_heatmap.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plots_0_heatmap.ipynb <plots_0_heatmap.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plots_0_heatmap.py <plots_0_heatmap.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plots_0_heatmap.zip <plots_0_heatmap.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
